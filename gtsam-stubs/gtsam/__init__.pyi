from typing import Iterable, Iterator, Tuple, Any

from typing import overload

import builtins
import numpy
import gtsam.noiseModel

from . import noiseModel, imuBias

def ConvertNoiseModel(model: gtsam.noiseModel.Base, d: int) -> gtsam.noiseModel.Base: ...
def IndexPairSetAsArray(*args, **kwargs) -> Any: ...
@overload
def PrintKeyList(keys: KeyList) -> None: ...
@overload
def PrintKeyList(keys: KeyList, s: str) -> None: ...
@overload
def PrintKeyList(*args, **kwargs) -> Any: ...
@overload
def PrintKeySet(keys: KeySet) -> None: ...
@overload
def PrintKeySet(keys: KeySet, s: str) -> None: ...
@overload
def PrintKeySet(*args, **kwargs) -> Any: ...
@overload
def PrintKeyVector(keys, tbb) -> None: ...
@overload
def PrintKeyVector(keys, tbb, s: str) -> None: ...
@overload
def PrintKeyVector(*args, **kwargs) -> Any: ...
@overload
def checkConvergence(relativeErrorTreshold: float, absoluteErrorTreshold: float, errorThreshold: float, currentError: float, newError: float) -> bool: ...
@overload
def checkConvergence(params: NonlinearOptimizerParams, currentError: float, newError: float) -> bool: ...
@overload
def checkConvergence(*args, **kwargs) -> Any: ...
def initialCamerasAndPointsEstimate(db: SfmData) -> Values: ...
def initialCamerasEstimate(db: SfmData) -> Values: ...
def isDebugVersion(*args, **kwargs) -> Any: ...
def linear_independent(A: numpy.ndarray, B: numpy.ndarray, tol: float) -> bool: ...
@overload
def load2D(filename: str, model: gtsam.noiseModel.Diagonal, maxIndex: int, addNoise: bool, smart: bool) -> Tuple[NonlinearFactorGraph,Values]: ...
@overload
def load2D(filename: str, model: gtsam.noiseModel.Diagonal, maxIndex: int, addNoise: bool) -> Tuple[NonlinearFactorGraph,Values]: ...
@overload
def load2D(filename: str, model: gtsam.noiseModel.Diagonal, maxIndex: int) -> Tuple[NonlinearFactorGraph,Values]: ...
@overload
def load2D(filename: str, model: gtsam.noiseModel.Diagonal) -> Tuple[NonlinearFactorGraph,Values]: ...
@overload
def load2D(filename: str) -> Tuple[NonlinearFactorGraph,Values]: ...
@overload
def load2D(*args, **kwargs) -> Any: ...
def load2D_robust(filename: str, model: gtsam.noiseModel.Base, maxIndex: int) -> Tuple[NonlinearFactorGraph,Values]: ...
def load3D(filename: str) -> Tuple[NonlinearFactorGraph,Values]: ...
def mrsymbol(c: int, label: int, j: int) -> int: ...
def mrsymbolChr(key: int) -> int: ...
def mrsymbolIndex(key: int) -> int: ...
def mrsymbolLabel(key: int) -> int: ...
def parse2DFactors(*args, **kwargs) -> Any: ...
def parse3DFactors(*args, **kwargs) -> Any: ...
def readBal(filename: str) -> SfmData: ...
@overload
def readG2o(filename: str) -> Tuple[NonlinearFactorGraph,Values]: ...
@overload
def readG2o(filename: str, is3D: bool) -> Tuple[NonlinearFactorGraph,Values]: ...
@overload
def readG2o(*args, **kwargs) -> Any: ...
def save2D(graph: NonlinearFactorGraph, config: Values, model: gtsam.noiseModel.Diagonal, filename: str) -> None: ...
def symbol(chr: str, index: int) -> int: ...
def symbolChr(key: int) -> int: ...
def symbolIndex(key: int) -> int: ...
def triangulatePoint3(*args, **kwargs) -> Any: ...
def writeBAL(filename: str, data: SfmData) -> bool: ...
def writeG2o(graph: NonlinearFactorGraph, estimate: Values, filename: str) -> None: ...

class AHRSFactor(NonlinearFactor):
    @overload
    def __init__(self, rot_i: int, rot_j: int, bias: int, preintegratedMeasurements: PreintegratedAhrsMeasurements, omegaCoriolis: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, rot_i: int, rot_j: int, bias: int, preintegratedMeasurements: PreintegratedAhrsMeasurements, omegaCoriolis: numpy.ndarray, body_P_sensor: Pose3) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def evaluateError(self, rot_i: Rot3, rot_j: Rot3, bias: numpy.ndarray) -> numpy.ndarray: ...
    def predict(self, rot_i: Rot3, bias: numpy.ndarray, preintegratedMeasurements: PreintegratedAhrsMeasurements, omegaCoriolis: numpy.ndarray) -> Rot3: ...
    def preintegratedMeasurements(self) -> PreintegratedAhrsMeasurements: ...

class AcceleratingScenario(Scenario):
    def __init__(self, nRb: Rot3, p0: numpy.ndarray, v0: numpy.ndarray, a_n: numpy.ndarray, omega_b: numpy.ndarray) -> None: ...

class BearingFactor2D(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: Rot2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class BearingFactor3D(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: Unit3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class BearingFactorPose2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: Rot2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class BearingRange2D:
    def __init__(self, b: Rot2, r: float) -> None: ...
    def Measure(self, *args, **kwargs) -> Any: ...
    def MeasureBearing(self, *args, **kwargs) -> Any: ...
    def MeasureRange(self, *args, **kwargs) -> Any: ...
    def bearing(self) -> Rot2: ...
    def print_(self, s: str) -> None: ...
    def range(self) -> float: ...

class BearingRangeFactor2D(NoiseModelFactor):
    def __init__(self, poseKey: int, pointKey: int, measuredBearing: Rot2, measuredRange: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> BearingRange2D: ...
    def serialize(self) -> str: ...

class BearingRangeFactorPose2(NoiseModelFactor):
    def __init__(self, poseKey: int, pointKey: int, measuredBearing: Rot2, measuredRange: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self, *args, **kwargs) -> Any: ...
    def serialize(self) -> str: ...

class BetweenFactorConstantBias(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, relativePose, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self, *args, **kwargs) -> Any: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class BetweenFactorPoint2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, relativePose: numpy.ndarray, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class BetweenFactorPoint3(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, relativePose: numpy.ndarray, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class BetweenFactorPose2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, relativePose: Pose2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> Pose2: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class BetweenFactorPose2s:
    __hash__: Any = ...
    __pybind11_module_local_v4_gcc_libstdcpp_cxxabi1014__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: BetweenFactorPose2s) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: BetweenFactorPose2) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: BetweenFactorPose2) -> int: ...
    @overload
    def extend(self, L: BetweenFactorPose2s) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: BetweenFactorPose2) -> None: ...
    @overload
    def pop(self) -> BetweenFactorPose2: ...
    @overload
    def pop(self, i: int) -> BetweenFactorPose2: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def remove(self, x: BetweenFactorPose2) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: BetweenFactorPose2) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    def __eq__(self, arg0: BetweenFactorPose2s) -> bool: ... # type: ignore[override]
    @overload
    def __getitem__(self, s: slice) -> BetweenFactorPose2s: ...
    @overload
    def __getitem__(self, arg0: int) -> BetweenFactorPose2: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: BetweenFactorPose2s) -> bool: ... # type: ignore[override]
    @overload
    def __setitem__(self, arg0: int, arg1: BetweenFactorPose2) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: BetweenFactorPose2s) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class BetweenFactorPose3(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, relativePose: Pose3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> Pose3: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class BetweenFactorPose3s:
    __hash__: Any = ...
    __pybind11_module_local_v4_gcc_libstdcpp_cxxabi1014__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: BetweenFactorPose3s) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: BetweenFactorPose3) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: BetweenFactorPose3) -> int: ...
    @overload
    def extend(self, L: BetweenFactorPose3s) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: BetweenFactorPose3) -> None: ...
    @overload
    def pop(self) -> BetweenFactorPose3: ...
    @overload
    def pop(self, i: int) -> BetweenFactorPose3: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def remove(self, x: BetweenFactorPose3) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: BetweenFactorPose3) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    def __eq__(self, arg0: BetweenFactorPose3s) -> bool: ... # type: ignore[override]
    @overload
    def __getitem__(self, s: slice) -> BetweenFactorPose3s: ...
    @overload
    def __getitem__(self, arg0: int) -> BetweenFactorPose3: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: BetweenFactorPose3s) -> bool: ... # type: ignore[override]
    @overload
    def __setitem__(self, arg0: int, arg1: BetweenFactorPose3) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: BetweenFactorPose3s) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class BetweenFactorRot2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, relativePose: Rot2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> Rot2: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class BetweenFactorRot3(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, relativePose: Rot3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> Rot3: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class BetweenFactorSO3(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, relativePose: SO3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> SO3: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class BetweenFactorSO4(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, relativePose: SO4, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> SO4: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class BetweenFactorVector(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, relativePose: numpy.ndarray, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class BinaryMeasurementRot3:
    def __init__(self, key1: int, key2: int, measured: Rot3, model: gtsam.noiseModel.Base) -> None: ...
    def key1(self) -> int: ...
    def key2(self) -> int: ...
    def measured(self) -> Rot3: ...
    def noiseModel(self) -> gtsam.noiseModel.Base: ...

class BinaryMeasurementUnit3:
    def __init__(self, key1: int, key2: int, measured: Unit3, model: gtsam.noiseModel.Base) -> None: ...
    def key1(self) -> int: ...
    def key2(self) -> int: ...
    def measured(self) -> Unit3: ...
    def noiseModel(self) -> gtsam.noiseModel.Base: ...

class BinaryMeasurementsUnit3:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: BinaryMeasurementsUnit3) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: BinaryMeasurementUnit3) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: BinaryMeasurementsUnit3) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: BinaryMeasurementUnit3) -> None: ...
    @overload
    def pop(self) -> BinaryMeasurementUnit3: ...
    @overload
    def pop(self, i: int) -> BinaryMeasurementUnit3: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    @overload
    def __getitem__(self, s: slice) -> BinaryMeasurementsUnit3: ...
    @overload
    def __getitem__(self, arg0: int) -> BinaryMeasurementUnit3: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: BinaryMeasurementUnit3) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: BinaryMeasurementsUnit3) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class Cal3Bundler:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, fx: float, k1: float, k2: float, u0: float, v0: float) -> None: ...
    @overload
    def __init__(self, fx: float, k1: float, k2: float, u0: float, v0: float, tol: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def K(self) -> numpy.ndarray: ...
    def calibrate(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def equals(self, rhs: Cal3Bundler, tol: float) -> bool: ...
    def fx(self) -> float: ...
    def fy(self) -> float: ...
    def k(self) -> numpy.ndarray: ...
    def k1(self) -> float: ...
    def k2(self) -> float: ...
    def localCoordinates(self, c: Cal3Bundler) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def px(self) -> float: ...
    def py(self) -> float: ...
    def retract(self, v: numpy.ndarray) -> Cal3Bundler: ...
    def serialize(self) -> str: ...
    def uncalibrate(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def vector(self) -> numpy.ndarray: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Cal3DS2(Cal3DS2_Base):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, k1: float, k2: float) -> None: ...
    @overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, k1: float, k2: float, p1: float, p2: float) -> None: ...
    @overload
    def __init__(self, v: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def equals(self, rhs: Cal3DS2, tol: float) -> bool: ...
    def localCoordinates(self, c: Cal3DS2) -> numpy.ndarray: ...
    def retract(self, v: numpy.ndarray) -> Cal3DS2: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Cal3DS2_Base:
    def __init__(self) -> None: ...
    def K(self) -> numpy.ndarray: ...
    def calibrate(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def deserialize(self, serialized: str) -> None: ...
    def fx(self) -> float: ...
    def fy(self) -> float: ...
    def k(self) -> numpy.ndarray: ...
    def k1(self) -> float: ...
    def k2(self) -> float: ...
    def print_(self, s: str) -> None: ...
    def px(self) -> float: ...
    def py(self) -> float: ...
    def serialize(self) -> str: ...
    def skew(self) -> float: ...
    def uncalibrate(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def vector(self) -> numpy.ndarray: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Cal3Unified(Cal3DS2_Base):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, k1: float, k2: float) -> None: ...
    @overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, k1: float, k2: float, p1: float, p2: float, xi: float) -> None: ...
    @overload
    def __init__(self, v: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def equals(self, rhs: Cal3Unified, tol: float) -> bool: ...
    def localCoordinates(self, c: Cal3Unified) -> numpy.ndarray: ...
    def nPlaneToSpace(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def retract(self, v: numpy.ndarray) -> Cal3Unified: ...
    def serialize(self) -> str: ...
    def spaceToNPlane(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def xi(self) -> float: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Cal3_S2:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float) -> None: ...
    @overload
    def __init__(self, v: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, fov: float, w: int, h: int) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def K(self) -> numpy.ndarray: ...
    def calibrate(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def equals(self, rhs: Cal3_S2, tol: float) -> bool: ...
    def fx(self) -> float: ...
    def fy(self) -> float: ...
    def inverse(self) -> numpy.ndarray: ...
    def localCoordinates(self, c: Cal3_S2) -> numpy.ndarray: ...
    def principalPoint(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def px(self) -> float: ...
    def py(self) -> float: ...
    def retract(self, v: numpy.ndarray) -> Cal3_S2: ...
    def serialize(self) -> str: ...
    def skew(self) -> float: ...
    def uncalibrate(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def vector(self) -> numpy.ndarray: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Cal3_S2Stereo:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, b: float) -> None: ...
    @overload
    def __init__(self, v: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def baseline(self) -> float: ...
    def equals(self, K: Cal3_S2Stereo, tol: float) -> bool: ...
    def fx(self) -> float: ...
    def fy(self) -> float: ...
    def principalPoint(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def px(self) -> float: ...
    def py(self) -> float: ...
    def skew(self) -> float: ...

class CalibratedCamera:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pose: Pose3) -> None: ...
    @overload
    def __init__(self, v: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def Level(self, *args, **kwargs) -> Any: ...
    def Project(self, *args, **kwargs) -> Any: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def equals(self, camera: CalibratedCamera, tol: float) -> bool: ...
    def localCoordinates(self, T2: CalibratedCamera) -> numpy.ndarray: ...
    def pose(self) -> Pose3: ...
    def print_(self, s: str) -> None: ...
    def project(self, point: numpy.ndarray) -> numpy.ndarray: ...
    @overload
    def range(self, point: numpy.ndarray) -> float: ...
    @overload
    def range(self, pose: Pose3) -> float: ...
    @overload
    def range(self, camera: CalibratedCamera) -> float: ...
    @overload
    def range(*args, **kwargs) -> Any: ...
    def retract(self, d: numpy.ndarray) -> CalibratedCamera: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class CameraSetCal3Bundler:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: CameraSetCal3Bundler) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: PinholeCameraCal3Bundler) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: CameraSetCal3Bundler) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: PinholeCameraCal3Bundler) -> None: ...
    @overload
    def pop(self) -> PinholeCameraCal3Bundler: ...
    @overload
    def pop(self, i: int) -> PinholeCameraCal3Bundler: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    @overload
    def __getitem__(self, s: slice) -> CameraSetCal3Bundler: ...
    @overload
    def __getitem__(self, arg0: int) -> PinholeCameraCal3Bundler: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: PinholeCameraCal3Bundler) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: CameraSetCal3Bundler) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class CameraSetCal3_S2:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: CameraSetCal3_S2) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: PinholeCameraCal3_S2) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: CameraSetCal3_S2) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: PinholeCameraCal3_S2) -> None: ...
    @overload
    def pop(self) -> PinholeCameraCal3_S2: ...
    @overload
    def pop(self, i: int) -> PinholeCameraCal3_S2: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    @overload
    def __getitem__(self, s: slice) -> CameraSetCal3_S2: ...
    @overload
    def __getitem__(self, arg0: int) -> PinholeCameraCal3_S2: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: PinholeCameraCal3_S2) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: CameraSetCal3_S2) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class CombinedImuFactor(NonlinearFactor):
    def __init__(self, pose_i: int, vel_i: int, pose_j: int, vel_j: int, bias_i: int, bias_j: int, CombinedPreintegratedMeasurements: PreintegratedCombinedMeasurements) -> None: ...
    def evaluateError(self, pose_i: Pose3, vel_i: numpy.ndarray, pose_j: Pose3, vel_j: numpy.ndarray, bias_i: imuBias.ConstantBias, bias_j: imuBias.ConstantBias) -> numpy.ndarray: ...
    def preintegratedMeasurements(self) -> PreintegratedCombinedMeasurements: ...

class ConjugateGradientParameters(IterativeOptimizationParameters):
    def __init__(self) -> None: ...
    def getEpsilon_abs(self) -> float: ...
    def getEpsilon_rel(self) -> float: ...
    def getMaxIterations(self) -> int: ...
    def getMinIterations(self) -> int: ...
    def getReset(self) -> int: ...
    def print_(self) -> None: ...
    def setEpsilon_abs(self, value: float) -> None: ...
    def setEpsilon_rel(self, value: float) -> None: ...
    def setMaxIterations(self, value: int) -> None: ...
    def setMinIterations(self, value: int) -> None: ...
    def setReset(self, value: int) -> None: ...

class ConstantTwistScenario(Scenario):
    @overload
    def __init__(self, w: numpy.ndarray, v: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, w: numpy.ndarray, v: numpy.ndarray, nTb0: Pose3) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...

class DSFMapIndexPair:
    def __init__(self) -> None: ...
    def find(self, key: IndexPair) -> IndexPair: ...
    def merge(self, x: IndexPair, y: IndexPair) -> None: ...
    def sets(self, *args, **kwargs) -> Any: ...

class DoglegOptimizer(NonlinearOptimizer):
    @overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: Values) -> None: ...
    @overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: Values, params: DoglegParams) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def getDelta(self) -> float: ...

class DoglegParams(NonlinearOptimizerParams):
    def __init__(self) -> None: ...
    def getDeltaInitial(self) -> float: ...
    def getVerbosityDL(self) -> str: ...
    def setDeltaInitial(self, deltaInitial: float) -> None: ...
    def setVerbosityDL(self, verbosityDL: str) -> None: ...

class DummyPreconditionerParameters(PreconditionerParameters):
    def __init__(self) -> None: ...

class Errors:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, V: VectorValues) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def equals(self, expected: Errors, tol: float) -> bool: ...
    def print_(self, s: str) -> None: ...

class EssentialMatrix:
    def __init__(self, aRb: Rot3, aTb: Unit3) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def dim(self) -> int: ...
    def direction(self) -> Unit3: ...
    def equals(self, pose: EssentialMatrix, tol: float) -> bool: ...
    def error(self, vA: numpy.ndarray, vB: numpy.ndarray) -> float: ...
    def localCoordinates(self, s: EssentialMatrix) -> numpy.ndarray: ...
    def matrix(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def retract(self, v: numpy.ndarray) -> EssentialMatrix: ...
    def rotation(self) -> Rot3: ...

class EssentialMatrixFactor(NoiseModelFactor):
    def __init__(self, key: int, pA: numpy.ndarray, pB: numpy.ndarray, noiseModel: gtsam.noiseModel.Base) -> None: ...

class FrobeniusBetweenFactorSO3(NoiseModelFactor):
    @overload
    def __init__(self, key1: int, key2: int, R12: SO3) -> None: ...
    @overload
    def __init__(self, key1: int, key2: int, R12: SO3, model: gtsam.noiseModel.Base) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def evaluateError(self, R1: SO3, R2: SO3) -> numpy.ndarray: ...

class FrobeniusBetweenFactorSO4(NoiseModelFactor):
    @overload
    def __init__(self, key1: int, key2: int, R12: SO4) -> None: ...
    @overload
    def __init__(self, key1: int, key2: int, R12: SO4, model: gtsam.noiseModel.Base) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def evaluateError(self, R1: SO4, R2: SO4) -> numpy.ndarray: ...

class FrobeniusFactorSO3(NoiseModelFactor):
    @overload
    def __init__(self, key1: int, key2: int) -> None: ...
    @overload
    def __init__(self, key1: int, key2: int, model: gtsam.noiseModel.Base) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def evaluateError(self, R1: SO3, R2: SO3) -> numpy.ndarray: ...

class FrobeniusFactorSO4(NoiseModelFactor):
    @overload
    def __init__(self, key1: int, key2: int) -> None: ...
    @overload
    def __init__(self, key1: int, key2: int, model: gtsam.noiseModel.Base) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def evaluateError(self, R1: SO4, R2: SO4) -> numpy.ndarray: ...

class GPSFactor(NonlinearFactor):
    def __init__(self, key: int, gpsIn: numpy.ndarray, model: gtsam.noiseModel.Base) -> None: ...
    def equals(self, expected: NonlinearFactor, tol: float) -> bool: ...
    def measurementIn(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...

class GPSFactor2(NonlinearFactor):
    def __init__(self, key: int, gpsIn: numpy.ndarray, model: gtsam.noiseModel.Base) -> None: ...
    def equals(self, expected: NonlinearFactor, tol: float) -> bool: ...
    def measurementIn(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...

class GaussNewtonOptimizer(NonlinearOptimizer):
    @overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: Values) -> None: ...
    @overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: Values, params: GaussNewtonParams) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...

class GaussNewtonParams(NonlinearOptimizerParams):
    def __init__(self) -> None: ...

class GaussianBayesNet:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, conditional: GaussianConditional) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def at(self, idx: int) -> GaussianConditional: ...
    def back(self) -> GaussianConditional: ...
    def backSubstitute(self, gx: VectorValues) -> VectorValues: ...
    def backSubstituteTranspose(self, gx: VectorValues) -> VectorValues: ...
    def determinant(self) -> float: ...
    def equals(self, other: GaussianBayesNet, tol: float) -> bool: ...
    def error(self, x: VectorValues) -> float: ...
    def exists(self, idx: int) -> bool: ...
    def front(self) -> GaussianConditional: ...
    def gradient(self, x0: VectorValues) -> VectorValues: ...
    def gradientAtZero(self) -> VectorValues: ...
    def keys(self) -> KeySet: ...
    def logDeterminant(self) -> float: ...
    @overload
    def optimize(self) -> VectorValues: ...
    @overload
    def optimize(self, solutionForMissing: VectorValues) -> VectorValues: ...
    @overload
    def optimize(*args, **kwargs) -> Any: ...
    def optimizeGradientSearch(self) -> VectorValues: ...
    def print_(self, s: str) -> None: ...
    @overload
    def push_back(self, conditional: GaussianConditional) -> None: ...
    @overload
    def push_back(self, bayesNet: GaussianBayesNet) -> None: ...
    @overload
    def push_back(*args, **kwargs) -> Any: ...
    def saveGraph(self, s: str) -> None: ...
    def size(self) -> int: ...

class GaussianBayesTree:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: GaussianBayesTree) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def determinant(self) -> float: ...
    def empty(self) -> bool: ...
    def equals(self, other: GaussianBayesTree, tol: float) -> bool: ...
    def error(self, x: VectorValues) -> float: ...
    def gradient(self, x0: VectorValues) -> VectorValues: ...
    def gradientAtZero(self) -> VectorValues: ...
    def joint(self, key1: int, key2: int) -> GaussianFactorGraph: ...
    def jointBayesNet(self, key1: int, key2: int) -> GaussianBayesNet: ...
    def logDeterminant(self) -> float: ...
    def marginalCovariance(self, key: int) -> numpy.ndarray: ...
    def marginalFactor(self, key: int) -> GaussianConditional: ...
    def numCachedSeparatorMarginals(self) -> int: ...
    def optimize(self) -> VectorValues: ...
    def optimizeGradientSearch(self) -> VectorValues: ...
    def print_(self, s: str) -> None: ...
    def saveGraph(self, s: str) -> None: ...
    def size(self) -> int: ...

class GaussianConditional(JacobianFactor):
    @overload
    def __init__(self, key: int, d: numpy.ndarray, R: numpy.ndarray, sigmas: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def __init__(self, key: int, d: numpy.ndarray, R: numpy.ndarray, name1: int, S: numpy.ndarray, sigmas: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def __init__(self, key: int, d: numpy.ndarray, R: numpy.ndarray, name1: int, S: numpy.ndarray, name2: int, T: numpy.ndarray, sigmas: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def __init__(self, key: int, d: numpy.ndarray, R: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, key: int, d: numpy.ndarray, R: numpy.ndarray, name1: int, S: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, key: int, d: numpy.ndarray, R: numpy.ndarray, name1: int, S: numpy.ndarray, name2: int, T: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def R(self) -> numpy.ndarray: ...
    def S(self) -> numpy.ndarray: ...
    def d(self) -> numpy.ndarray: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, cg: GaussianFactor, tol: float) -> bool: ...
    def print_(self, s: str) -> None: ...
    def scaleFrontalsBySigma(self, gy: VectorValues) -> None: ...
    def serialize(self) -> str: ...
    def solve(self, parents: VectorValues) -> VectorValues: ...
    def solveOtherRHS(self, parents: VectorValues, rhs: VectorValues) -> VectorValues: ...
    def solveTransposeInPlace(self, gy: VectorValues) -> None: ...

class GaussianDensity(GaussianConditional):
    def __init__(self, key: int, d: numpy.ndarray, R: numpy.ndarray, sigmas: gtsam.noiseModel.Diagonal) -> None: ...
    def covariance(self) -> numpy.ndarray: ...
    def equals(self, cg: GaussianFactor, tol: float) -> bool: ...
    def mean(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...

class GaussianFactor:
    def __init__(self, *args, **kwargs) -> None: ...
    def augmentedInformation(self) -> numpy.ndarray: ...
    def augmentedJacobian(self) -> numpy.ndarray: ...
    def clone(self) -> GaussianFactor: ...
    def empty(self) -> bool: ...
    def equals(self, lf: GaussianFactor, tol: float) -> bool: ...
    def error(self, c: VectorValues) -> float: ...
    def information(self) -> numpy.ndarray: ...
    def jacobian(self) -> Tuple[numpy.ndarray,numpy.ndarray]: ...
    def keys(self, *args, **kwargs) -> Any: ...
    def negate(self) -> GaussianFactor: ...
    def print_(self, s: str) -> None: ...
    def size(self) -> int: ...

class GaussianFactorGraph:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, bayesNet) -> None: ...
    @overload
    def __init__(self, bayesTree) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    @overload
    def add(self, factor: GaussianFactor) -> None: ...
    @overload
    def add(self, b: numpy.ndarray) -> None: ...
    @overload
    def add(self, key1: int, A1: numpy.ndarray, b: numpy.ndarray, model: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def add(self, key1: int, A1: numpy.ndarray, key2: int, A2: numpy.ndarray, b: numpy.ndarray, model: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def add(self, key1: int, A1: numpy.ndarray, key2: int, A2: numpy.ndarray, key3: int, A3: numpy.ndarray, b: numpy.ndarray, model: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def add(*args, **kwargs) -> Any: ...
    def at(self, idx: int) -> GaussianFactor: ...
    @overload
    def augmentedHessian(self) -> numpy.ndarray: ...
    @overload
    def augmentedHessian(self, ordering) -> numpy.ndarray: ...
    @overload
    def augmentedHessian(*args, **kwargs) -> Any: ...
    @overload
    def augmentedJacobian(self) -> numpy.ndarray: ...
    @overload
    def augmentedJacobian(self, ordering) -> numpy.ndarray: ...
    @overload
    def augmentedJacobian(*args, **kwargs) -> Any: ...
    def clone(self) -> GaussianFactorGraph: ...
    def deserialize(self, serialized: str) -> None: ...
    def eliminateMultifrontal(*args, **kwargs) -> Any: ...
    def eliminatePartialMultifrontal(*args, **kwargs) -> Any: ...
    def eliminatePartialSequential(*args, **kwargs) -> Any: ...
    def eliminateSequential(*args, **kwargs) -> Any: ...
    def equals(self, lfgraph: GaussianFactorGraph, tol: float) -> bool: ...
    def error(self, c: VectorValues) -> float: ...
    def exists(self, idx: int) -> bool: ...
    def gradient(self, x0: VectorValues) -> VectorValues: ...
    def gradientAtZero(self) -> VectorValues: ...
    @overload
    def hessian(self) -> Tuple[numpy.ndarray,numpy.ndarray]: ...
    @overload
    def hessian(self, ordering) -> Tuple[numpy.ndarray,numpy.ndarray]: ...
    @overload
    def hessian(*args, **kwargs) -> Any: ...
    @overload
    def jacobian(self) -> Tuple[numpy.ndarray,numpy.ndarray]: ...
    @overload
    def jacobian(self, ordering) -> Tuple[numpy.ndarray,numpy.ndarray]: ...
    @overload
    def jacobian(*args, **kwargs) -> Any: ...
    def keyVector(self, *args, **kwargs) -> Any: ...
    def keys(self) -> KeySet: ...
    def marginal(self, key_vector, tbb) -> GaussianFactorGraph: ...
    def marginalMultifrontalBayesNet(*args, **kwargs) -> Any: ...
    def negate(self) -> GaussianFactorGraph: ...
    @overload
    def optimize(self) -> VectorValues: ...
    @overload
    def optimize(self, ordering) -> VectorValues: ...
    @overload
    def optimize(*args, **kwargs) -> Any: ...
    def optimizeGradientSearch(self) -> VectorValues: ...
    def print_(self, s: str) -> None: ...
    def probPrime(self, c: VectorValues) -> float: ...
    @overload
    def push_back(self, factor: GaussianFactor) -> None: ...
    @overload
    def push_back(self, conditional) -> None: ...
    @overload
    def push_back(self, graph: GaussianFactorGraph) -> None: ...
    @overload
    def push_back(self, bayesNet) -> None: ...
    @overload
    def push_back(self, bayesTree) -> None: ...
    @overload
    def push_back(*args, **kwargs) -> Any: ...
    def serialize(self) -> str: ...
    def size(self) -> int: ...
    def sparseJacobian_(self) -> numpy.ndarray: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class GaussianISAM:
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def saveGraph(self, s: str) -> None: ...
    def update(self, newFactors: GaussianFactorGraph) -> None: ...

class GeneralSFMFactor2Cal3Bundler(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray, model: gtsam.noiseModel.Base, poseKey: int, landmarkKey: int, calibKey: int) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...

class GeneralSFMFactor2Cal3DS2(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray, model: gtsam.noiseModel.Base, poseKey: int, landmarkKey: int, calibKey: int) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...

class GeneralSFMFactor2Cal3_S2(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray, model: gtsam.noiseModel.Base, poseKey: int, landmarkKey: int, calibKey: int) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...

class GeneralSFMFactorCal3Bundler(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray, model: gtsam.noiseModel.Base, cameraKey: int, landmarkKey: int) -> None: ...
    def measured(self) -> numpy.ndarray: ...

class GeneralSFMFactorCal3DS2(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray, model: gtsam.noiseModel.Base, cameraKey: int, landmarkKey: int) -> None: ...
    def measured(self) -> numpy.ndarray: ...

class GeneralSFMFactorCal3_S2(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray, model: gtsam.noiseModel.Base, cameraKey: int, landmarkKey: int) -> None: ...
    def measured(self) -> numpy.ndarray: ...

class GenericProjectionFactorCal3DS2(NoiseModelFactor):
    @overload
    def __init__(self, measured: numpy.ndarray, noiseModel: gtsam.noiseModel.Base, poseKey: int, pointKey: int, k: Cal3DS2) -> None: ...
    @overload
    def __init__(self, measured: numpy.ndarray, noiseModel: gtsam.noiseModel.Base, poseKey: int, pointKey: int, k: Cal3DS2, body_P_sensor: Pose3) -> None: ...
    @overload
    def __init__(self, measured: numpy.ndarray, noiseModel: gtsam.noiseModel.Base, poseKey: int, pointKey: int, k: Cal3DS2, throwCheirality: bool, verboseCheirality: bool) -> None: ...
    @overload
    def __init__(self, measured: numpy.ndarray, noiseModel: gtsam.noiseModel.Base, poseKey: int, pointKey: int, k: Cal3DS2, throwCheirality: bool, verboseCheirality: bool, body_P_sensor: Pose3) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def calibration(self) -> Cal3DS2: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...
    def throwCheirality(self) -> bool: ...
    def verboseCheirality(self) -> bool: ...

class GenericProjectionFactorCal3_S2(NoiseModelFactor):
    @overload
    def __init__(self, measured: numpy.ndarray, noiseModel: gtsam.noiseModel.Base, poseKey: int, pointKey: int, k: Cal3_S2) -> None: ...
    @overload
    def __init__(self, measured: numpy.ndarray, noiseModel: gtsam.noiseModel.Base, poseKey: int, pointKey: int, k: Cal3_S2, body_P_sensor: Pose3) -> None: ...
    @overload
    def __init__(self, measured: numpy.ndarray, noiseModel: gtsam.noiseModel.Base, poseKey: int, pointKey: int, k: Cal3_S2, throwCheirality: bool, verboseCheirality: bool) -> None: ...
    @overload
    def __init__(self, measured: numpy.ndarray, noiseModel: gtsam.noiseModel.Base, poseKey: int, pointKey: int, k: Cal3_S2, throwCheirality: bool, verboseCheirality: bool, body_P_sensor: Pose3) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def calibration(self) -> Cal3_S2: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...
    def throwCheirality(self) -> bool: ...
    def verboseCheirality(self) -> bool: ...

class GenericStereoFactor3D(NoiseModelFactor):
    def __init__(self, measured: StereoPoint2, noiseModel: gtsam.noiseModel.Base, poseKey: int, landmarkKey: int, K: Cal3_S2Stereo) -> None: ...
    def calibration(self) -> Cal3_S2Stereo: ...
    def deserialize(self, serialized: str) -> None: ...
    def measured(self) -> StereoPoint2: ...
    def serialize(self) -> str: ...

class GenericValueCal3Bundler(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValueCal3DS2(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValueCal3_S2(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValueCalibratedCamera(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValueConstantBias(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValueEssentialMatrix(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValueMatrix(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValuePoint2(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValuePoint3(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValuePose2(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValuePose3(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValueRot2(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValueRot3(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValueStereoPoint2(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class GenericValueVector(Value):
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class HessianFactor(GaussianFactor):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, factor: GaussianFactor) -> None: ...
    @overload
    def __init__(self, j: int, G: numpy.ndarray, g: numpy.ndarray, f: float) -> None: ...
    @overload
    def __init__(self, j: int, mu: numpy.ndarray, Sigma: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, j1: int, j2: int, G11: numpy.ndarray, G12: numpy.ndarray, g1: numpy.ndarray, G22: numpy.ndarray, g2: numpy.ndarray, f: float) -> None: ...
    @overload
    def __init__(self, j1: int, j2: int, j3: int, G11: numpy.ndarray, G12: numpy.ndarray, G13: numpy.ndarray, g1: numpy.ndarray, G22: numpy.ndarray, G23: numpy.ndarray, g2: numpy.ndarray, G33: numpy.ndarray, g3: numpy.ndarray, f: float) -> None: ...
    @overload
    def __init__(self, factors) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def constantTerm(self) -> float: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, lf: GaussianFactor, tol: float) -> bool: ...
    def error(self, c: VectorValues) -> float: ...
    def information(self) -> numpy.ndarray: ...
    def linearTerm(self) -> numpy.ndarray: ...
    def printKeys(self, s: str) -> None: ...
    def print_(self, s: str) -> None: ...
    def rows(self) -> int: ...
    def serialize(self) -> str: ...
    def size(self) -> int: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class ISAM2:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, params: ISAM2Params) -> None: ...
    @overload
    def __init__(self, other: ISAM2) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def calculateBestEstimate(self) -> Values: ...
    def calculateEstimate(self) -> Values: ...
    def calculateEstimateCal3Bundler(self, key: int) -> Cal3Bundler: ...
    def calculateEstimateCal3DS2(self, key: int) -> Cal3DS2: ...
    def calculateEstimateCal3_S2(self, key: int) -> Cal3_S2: ...
    def calculateEstimateEssentialMatrix(self, key: int) -> EssentialMatrix: ...
    def calculateEstimateMatrix(self, key: int) -> numpy.ndarray: ...
    def calculateEstimatePinholeCameraCal3Bundler(self, *args, **kwargs) -> Any: ...
    def calculateEstimatePinholeCameraCal3_S2(self, *args, **kwargs) -> Any: ...
    def calculateEstimatePoint2(self, key: int) -> numpy.ndarray: ...
    def calculateEstimatePoint3(self, key: int) -> numpy.ndarray: ...
    def calculateEstimatePose2(self, key: int) -> Pose2: ...
    def calculateEstimatePose3(self, key: int) -> Pose3: ...
    def calculateEstimateRot2(self, key: int) -> Rot2: ...
    def calculateEstimateRot3(self, key: int) -> Rot3: ...
    def calculateEstimateVector(self, key: int) -> numpy.ndarray: ...
    def equals(self, other: ISAM2, tol: float) -> bool: ...
    def getDelta(self) -> VectorValues: ...
    def getFactorsUnsafe(self) -> NonlinearFactorGraph: ...
    def getLinearizationPoint(self) -> Values: ...
    def getVariableIndex(self) -> VariableIndex: ...
    def marginalCovariance(self, key: int) -> numpy.ndarray: ...
    def params(self) -> ISAM2Params: ...
    def printStats(self) -> None: ...
    def print_(self, s: str) -> None: ...
    def saveGraph(self, s: str) -> None: ...
    @overload
    def update(self) -> ISAM2Result: ...
    @overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: Values) -> ISAM2Result: ...
    @overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: Values, removeFactorIndices, tbb) -> ISAM2Result: ...
    @overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: Values, removeFactorIndices, tbb, constrainedKeys: KeyGroupMap) -> ISAM2Result: ...
    @overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: Values, removeFactorIndices, tbb, constrainedKeys: KeyGroupMap, noRelinKeys: KeyList) -> ISAM2Result: ...
    @overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: Values, removeFactorIndices, tbb, constrainedKeys: KeyGroupMap, noRelinKeys: KeyList, extraReelimKeys: KeyList) -> ISAM2Result: ...
    @overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: Values, removeFactorIndices, tbb, constrainedKeys: KeyGroupMap, noRelinKeys: KeyList, extraReelimKeys: KeyList, force_relinearize: bool) -> ISAM2Result: ...
    @overload
    def update(*args, **kwargs) -> Any: ...

class ISAM2Clique:
    def __init__(self) -> None: ...
    def gradientContribution(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...

class ISAM2DoglegParams:
    def __init__(self) -> None: ...
    def getAdaptationMode(self) -> str: ...
    def getInitialDelta(self) -> float: ...
    def getWildfireThreshold(self) -> float: ...
    def isVerbose(self) -> bool: ...
    def print_(self, str: str) -> None: ...
    def setAdaptationMode(self, adaptationMode: str) -> None: ...
    def setInitialDelta(self, initialDelta: float) -> None: ...
    def setVerbose(self, verbose: bool) -> None: ...
    def setWildfireThreshold(self, wildfireThreshold: float) -> None: ...

class ISAM2GaussNewtonParams:
    def __init__(self) -> None: ...
    def getWildfireThreshold(self) -> float: ...
    def print_(self, str: str) -> None: ...
    def setWildfireThreshold(self, wildfireThreshold: float) -> None: ...

class ISAM2Params:
    def __init__(self) -> None: ...
    def getFactorization(self) -> str: ...
    def getRelinearizeSkip(self) -> int: ...
    def isCacheLinearizedFactors(self) -> bool: ...
    def isEnableDetailedResults(self) -> bool: ...
    def isEnablePartialRelinearizationCheck(self) -> bool: ...
    def isEnableRelinearization(self) -> bool: ...
    def isEvaluateNonlinearError(self) -> bool: ...
    def print_(self, str: str) -> None: ...
    def setCacheLinearizedFactors(self, cacheLinearizedFactors: bool) -> None: ...
    def setEnableDetailedResults(self, enableDetailedResults: bool) -> None: ...
    def setEnablePartialRelinearizationCheck(self, enablePartialRelinearizationCheck: bool) -> None: ...
    def setEnableRelinearization(self, enableRelinearization: bool) -> None: ...
    def setEvaluateNonlinearError(self, evaluateNonlinearError: bool) -> None: ...
    def setFactorization(self, factorization: str) -> None: ...
    @overload
    def setOptimizationParams(self, gauss_newton__params: ISAM2GaussNewtonParams) -> None: ...
    @overload
    def setOptimizationParams(self, dogleg_params: ISAM2DoglegParams) -> None: ...
    @overload
    def setOptimizationParams(*args, **kwargs) -> Any: ...
    def setRelinearizeSkip(self, relinearizeSkip: int) -> None: ...
    @overload
    def setRelinearizeThreshold(self, threshold: float) -> None: ...
    @overload
    def setRelinearizeThreshold(self, threshold_map: ISAM2ThresholdMap) -> None: ...
    @overload
    def setRelinearizeThreshold(*args, **kwargs) -> Any: ...

class ISAM2Result:
    def __init__(self) -> None: ...
    def getCliques(self) -> int: ...
    def getErrorAfter(self) -> float: ...
    def getErrorBefore(self) -> float: ...
    def getVariablesReeliminated(self) -> int: ...
    def getVariablesRelinearized(self) -> int: ...
    def print_(self, str: str) -> None: ...

class ISAM2ThresholdMap:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: ISAM2ThresholdMap) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def insert(self, value: Tuple[str,numpy.ndarray]) -> None: ...
    def size(self) -> int: ...

class ImuFactor(NonlinearFactor):
    def __init__(self, pose_i: int, vel_i: int, pose_j: int, vel_j: int, bias: int, preintegratedMeasurements: PreintegratedImuMeasurements) -> None: ...
    def evaluateError(self, pose_i: Pose3, vel_i: numpy.ndarray, pose_j: Pose3, vel_j: numpy.ndarray, bias: imuBias.ConstantBias) -> numpy.ndarray: ...
    def preintegratedMeasurements(self) -> PreintegratedImuMeasurements: ...

class IndexPair:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, i: int, j: int) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def i(self) -> int: ...
    def j(self) -> int: ...

class IndexPairSet:
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def count(self, key: IndexPair) -> int: ...
    def empty(self) -> bool: ...
    def erase(self, key: IndexPair) -> int: ...
    def insert(self, key: IndexPair) -> None: ...
    def size(self) -> int: ...

class IndexPairSetMap:
    def __init__(self) -> None: ...
    def items(self) -> Iterator: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, arg0: IndexPair) -> bool: ...
    def __delitem__(self, arg0: IndexPair) -> None: ...
    def __getitem__(self, arg0: IndexPair) -> IndexPairSet: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: IndexPair, arg1: IndexPairSet) -> None: ...

class IndexPairVector:
    __hash__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: IndexPairVector) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: IndexPair) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: IndexPair) -> int: ...
    @overload
    def extend(self, L: IndexPairVector) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: IndexPair) -> None: ...
    @overload
    def pop(self) -> IndexPair: ...
    @overload
    def pop(self, i: int) -> IndexPair: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def remove(self, x: IndexPair) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: IndexPair) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    def __eq__(self, arg0: IndexPairVector) -> bool: ... # type: ignore[override]
    @overload
    def __getitem__(self, s: slice) -> IndexPairVector: ...
    @overload
    def __getitem__(self, arg0: int) -> IndexPair: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: IndexPairVector) -> bool: ... # type: ignore[override]
    @overload
    def __setitem__(self, arg0: int, arg1: IndexPair) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: IndexPairVector) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class InitializePose3:
    def __init__(self, *args, **kwargs) -> None: ...
    def buildPose3graph(self, *args, **kwargs) -> Any: ...
    def computeOrientationsChordal(self, *args, **kwargs) -> Any: ...
    def computeOrientationsGradient(self, *args, **kwargs) -> Any: ...
    def initialize(self, *args, **kwargs) -> Any: ...
    def initializeOrientations(self, *args, **kwargs) -> Any: ...

class IterativeOptimizationParameters:
    def __init__(self, *args, **kwargs) -> None: ...
    def getVerbosity(self) -> str: ...
    def print_(self) -> None: ...
    def setVerbosity(self, s: str) -> None: ...

class JacobianFactor(GaussianFactor):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, factor: GaussianFactor) -> None: ...
    @overload
    def __init__(self, b_in: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, i1: int, A1: numpy.ndarray, b: numpy.ndarray, model: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def __init__(self, i1: int, A1: numpy.ndarray, i2: int, A2: numpy.ndarray, b: numpy.ndarray, model: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def __init__(self, i1: int, A1: numpy.ndarray, i2: int, A2: numpy.ndarray, i3: int, A3: numpy.ndarray, b: numpy.ndarray, model: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def __init__(self, graph) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def augmentedJacobianUnweighted(self) -> numpy.ndarray: ...
    def cols(self) -> int: ...
    def deserialize(self, serialized: str) -> None: ...
    def eliminate(self, *args, **kwargs) -> Any: ...
    def equals(self, lf: GaussianFactor, tol: float) -> bool: ...
    def error(self, c: VectorValues) -> float: ...
    def error_vector(self, c: VectorValues) -> numpy.ndarray: ...
    def getA(self) -> numpy.ndarray: ...
    def get_model(self) -> gtsam.noiseModel.Diagonal: ...
    def getb(self) -> numpy.ndarray: ...
    def isConstrained(self) -> bool: ...
    def jacobianUnweighted(self) -> Tuple[numpy.ndarray,numpy.ndarray]: ...
    def printKeys(self, s: str) -> None: ...
    def print_(self, s: str) -> None: ...
    def rows(self) -> int: ...
    def serialize(self) -> str: ...
    def setModel(self, anyConstrained: bool, sigmas: numpy.ndarray) -> None: ...
    def size(self) -> int: ...
    def transposeMultiplyAdd(self, alpha: float, e: numpy.ndarray, x: VectorValues) -> None: ...
    def unweighted_error(self, c: VectorValues) -> numpy.ndarray: ...
    def whiten(self) -> JacobianFactor: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class JointMarginal:
    def __init__(self, *args, **kwargs) -> None: ...
    def at(self, iVariable: int, jVariable: int) -> numpy.ndarray: ...
    def fullMatrix(self) -> numpy.ndarray: ...
    @overload
    def print_(self, s: str) -> None: ...
    @overload
    def print_(self) -> None: ...
    @overload
    def print_(*args, **kwargs) -> Any: ...

class KalmanFilter:
    def __init__(self, n: int) -> None: ...
    def init(self, x0: numpy.ndarray, P0: numpy.ndarray) -> GaussianDensity: ...
    def predict(self, p: GaussianDensity, F: numpy.ndarray, B: numpy.ndarray, u: numpy.ndarray, modelQ: gtsam.noiseModel.Diagonal) -> GaussianDensity: ...
    def predict2(self, p: GaussianDensity, A0: numpy.ndarray, A1: numpy.ndarray, b: numpy.ndarray, model: gtsam.noiseModel.Diagonal) -> GaussianDensity: ...
    def predictQ(self, p: GaussianDensity, F: numpy.ndarray, B: numpy.ndarray, u: numpy.ndarray, Q: numpy.ndarray) -> GaussianDensity: ...
    def print_(self, s: str) -> None: ...
    def step(self, *args, **kwargs) -> Any: ...
    def update(self, p: GaussianDensity, H: numpy.ndarray, z: numpy.ndarray, model: gtsam.noiseModel.Diagonal) -> GaussianDensity: ...
    def updateQ(self, p: GaussianDensity, H: numpy.ndarray, z: numpy.ndarray, Q: numpy.ndarray) -> GaussianDensity: ...

class KarcherMeanFactorPoint2(NonlinearFactor):
    def __init__(self, keys, tbb) -> None: ...

class KarcherMeanFactorPoint3(NonlinearFactor):
    def __init__(self, keys, tbb) -> None: ...

class KarcherMeanFactorPose2(NonlinearFactor):
    def __init__(self, keys, tbb) -> None: ...

class KarcherMeanFactorPose3(NonlinearFactor):
    def __init__(self, keys, tbb) -> None: ...

class KarcherMeanFactorRot2(NonlinearFactor):
    def __init__(self, keys, tbb) -> None: ...

class KarcherMeanFactorRot3(NonlinearFactor):
    def __init__(self, keys, tbb) -> None: ...

class KarcherMeanFactorSO3(NonlinearFactor):
    def __init__(self, keys, tbb) -> None: ...

class KarcherMeanFactorSO4(NonlinearFactor):
    def __init__(self, keys, tbb) -> None: ...

class KeyGroupMap:
    def __init__(self) -> None: ...
    def at(self, key: int) -> int: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def erase(self, key: int) -> int: ...
    def insert2(self, key: int, val: int) -> bool: ...
    def size(self) -> int: ...

class KeyList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: KeyList) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def back(self) -> int: ...
    def clear(self) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def empty(self) -> bool: ...
    def front(self) -> int: ...
    def pop_back(self) -> None: ...
    def pop_front(self) -> None: ...
    def push_back(self, key: int) -> None: ...
    def push_front(self, key: int) -> None: ...
    def remove(self, key: int) -> None: ...
    def serialize(self) -> str: ...
    def size(self) -> int: ...
    def sort(self) -> None: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class KeyPairDoubleMap:
    __pybind11_module_local_v4_gcc_libstdcpp_cxxabi1014__: Any = ...
    def __init__(self) -> None: ...
    def items(self) -> Iterator: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, arg0: Tuple[int,int]) -> bool: ...
    def __delitem__(self, arg0: Tuple[int,int]) -> None: ...
    def __getitem__(self, arg0: Tuple[int,int]) -> float: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: Tuple[int,int], arg1: float) -> None: ...

class KeySet:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, set: KeySet) -> None: ...
    @overload
    def __init__(self, vector, tbb) -> None: ...
    @overload
    def __init__(self, list: KeyList) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def clear(self) -> None: ...
    def count(self, key: int) -> int: ...
    def deserialize(self, serialized: str) -> None: ...
    def empty(self) -> bool: ...
    def equals(self, other: KeySet) -> bool: ...
    def erase(self, key: int) -> int: ...
    def insert(self, key: int) -> None: ...
    def merge(self, other: KeySet) -> None: ...
    def print_(self, s: str) -> None: ...
    def serialize(self) -> str: ...
    def size(self) -> int: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class KeyVector:
    __hash__: Any = ...
    __pybind11_module_local_v4_gcc_libstdcpp_cxxabi1014__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: KeyVector) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: int) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: int) -> int: ...
    @overload
    def extend(self, L: KeyVector) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: int) -> None: ...
    @overload
    def pop(self) -> int: ...
    @overload
    def pop(self, i: int) -> int: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def remove(self, x: int) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: int) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    def __eq__(self, arg0: KeyVector) -> bool: ... # type: ignore[override]
    @overload
    def __getitem__(self, s: slice) -> KeyVector: ...
    @overload
    def __getitem__(self, arg0: int) -> int: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: KeyVector) -> bool: ... # type: ignore[override]
    @overload
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: KeyVector) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class LabeledSymbol:
    @overload
    def __init__(self, full_key: int) -> None: ...
    @overload
    def __init__(self, key: LabeledSymbol) -> None: ...
    @overload
    def __init__(self, valType: int, label: int, j: int) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def chr(self) -> int: ...
    def index(self) -> int: ...
    def key(self) -> int: ...
    def label(self) -> int: ...
    def lower(self) -> LabeledSymbol: ...
    def newChr(self, c: int) -> LabeledSymbol: ...
    def newLabel(self, label: int) -> LabeledSymbol: ...
    def print_(self, s: str) -> None: ...
    def upper(self) -> LabeledSymbol: ...

class LevenbergMarquardtOptimizer(NonlinearOptimizer):
    @overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: Values) -> None: ...
    @overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: Values, params: LevenbergMarquardtParams) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def lambda_(self) -> float: ...
    def print_(self, str: str) -> None: ...

class LevenbergMarquardtParams(NonlinearOptimizerParams):
    def __init__(self) -> None: ...
    def CeresDefaults(self, *args, **kwargs) -> Any: ...
    def EnsureHasOrdering(self, *args, **kwargs) -> Any: ...
    def LegacyDefaults(self, *args, **kwargs) -> Any: ...
    def ReplaceOrdering(self, *args, **kwargs) -> Any: ...
    def getDiagonalDamping(self) -> bool: ...
    def getLogFile(self) -> str: ...
    def getUseFixedLambdaFactor(self) -> bool: ...
    def getVerbosityLM(self) -> str: ...
    def getlambdaFactor(self) -> float: ...
    def getlambdaInitial(self) -> float: ...
    def getlambdaLowerBound(self) -> float: ...
    def getlambdaUpperBound(self) -> float: ...
    def setDiagonalDamping(self, flag: bool) -> None: ...
    def setLogFile(self, s: str) -> None: ...
    def setUseFixedLambdaFactor(self, flag: bool) -> None: ...
    def setVerbosityLM(self, s: str) -> None: ...
    def setlambdaFactor(self, value: float) -> None: ...
    def setlambdaInitial(self, value: float) -> None: ...
    def setlambdaLowerBound(self, value: float) -> None: ...
    def setlambdaUpperBound(self, value: float) -> None: ...

class LinearContainerFactor(NonlinearFactor):
    @overload
    def __init__(self, factor: GaussianFactor, linearizationPoint: Values) -> None: ...
    @overload
    def __init__(self, factor: GaussianFactor) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def ConvertLinearGraph(self, *args, **kwargs) -> Any: ...
    def deserialize(self, serialized: str) -> None: ...
    def factor(self) -> GaussianFactor: ...
    def isJacobian(self) -> bool: ...
    def serialize(self) -> str: ...
    def toHessian(self) -> HessianFactor: ...
    def toJacobian(self) -> JacobianFactor: ...

class MFAS:
    def __init__(self, relativeTranslations, std, projectionDirection: Unit3) -> None: ...
    def computeOrdering(self, *args, **kwargs) -> Any: ...
    def computeOutlierWeights(self, *args, **kwargs) -> Any: ...

class Marginals:
    @overload
    def __init__(self, graph: NonlinearFactorGraph, solution: Values) -> None: ...
    @overload
    def __init__(self, gfgraph: GaussianFactorGraph, solution: Values) -> None: ...
    @overload
    def __init__(self, gfgraph: GaussianFactorGraph, solutionvec: VectorValues) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def jointMarginalCovariance(self, *args, **kwargs) -> Any: ...
    def jointMarginalInformation(self, *args, **kwargs) -> Any: ...
    def marginalCovariance(self, variable: int) -> numpy.ndarray: ...
    def marginalInformation(self, variable: int) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...

class NavState:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, R: Rot3, t: numpy.ndarray, v: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, pose: Pose3, v: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def attitude(self) -> Rot3: ...
    def equals(self, expected: NavState, tol: float) -> bool: ...
    def localCoordinates(self, g: NavState) -> numpy.ndarray: ...
    def pose(self) -> Pose3: ...
    def position(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def retract(self, x: numpy.ndarray) -> NavState: ...
    def velocity(self) -> numpy.ndarray: ...

class NoiseModelFactor(NonlinearFactor):
    def __init__(self, *args, **kwargs) -> None: ...
    def equals(self, other: NoiseModelFactor, tol: float) -> bool: ... # type: ignore[override]
    def noiseModel(self) -> gtsam.noiseModel.Base: ...
    def unwhitenedError(self, x) -> numpy.ndarray: ...
    def whitenedError(self, x) -> numpy.ndarray: ...

class NonlinearEqualityCal3_S2(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: Cal3_S2) -> None: ...
    @overload
    def __init__(self, j: int, feasible: Cal3_S2, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualityCalibratedCamera(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: CalibratedCamera) -> None: ...
    @overload
    def __init__(self, j: int, feasible: CalibratedCamera, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualityConstantBias(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible) -> None: ...
    @overload
    def __init__(self, j: int, feasible, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualityPinholeCameraCal3_S2(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible) -> None: ...
    @overload
    def __init__(self, j: int, feasible, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualityPoint2(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, j: int, feasible: numpy.ndarray, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualityPoint3(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, j: int, feasible: numpy.ndarray, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualityPose2(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: Pose2) -> None: ...
    @overload
    def __init__(self, j: int, feasible: Pose2, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualityPose3(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: Pose3) -> None: ...
    @overload
    def __init__(self, j: int, feasible: Pose3, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualityRot2(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: Rot2) -> None: ...
    @overload
    def __init__(self, j: int, feasible: Rot2, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualityRot3(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: Rot3) -> None: ...
    @overload
    def __init__(self, j: int, feasible: Rot3, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualitySO3(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: SO3) -> None: ...
    @overload
    def __init__(self, j: int, feasible: SO3, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualitySO4(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: SO4) -> None: ...
    @overload
    def __init__(self, j: int, feasible: SO4, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualitySOn(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: SOn) -> None: ...
    @overload
    def __init__(self, j: int, feasible: SOn, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearEqualityStereoPoint2(NoiseModelFactor):
    @overload
    def __init__(self, j: int, feasible: StereoPoint2) -> None: ...
    @overload
    def __init__(self, j: int, feasible: StereoPoint2, error_gain: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class NonlinearFactor:
    def __init__(self, *args, **kwargs) -> None: ...
    def active(self, c) -> bool: ...
    def clone(self) -> NonlinearFactor: ...
    def dim(self) -> int: ...
    def equals(self, other: NonlinearFactor, tol: float) -> bool: ...
    def error(self, c) -> float: ...
    def keys(self, *args, **kwargs) -> Any: ...
    def linearize(self, c) -> GaussianFactor: ...
    def printKeys(self, s: str) -> None: ...
    def print_(self, s: str) -> None: ...
    def size(self) -> int: ...

class NonlinearFactorGraph:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, graph: NonlinearFactorGraph) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def add(self, factor) -> None: ...
    def addPriorCal3_S2(self, key: int, prior: Cal3_S2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorCalibratedCamera(self, key: int, prior: CalibratedCamera, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorConstantBias(self, key: int, prior, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorDouble(self, key: int, prior: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorPinholeCameraCal3Bundler(self, key: int, prior, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorPinholeCameraCal3_S2(self, key: int, prior, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorPoint2(self, key: int, prior: numpy.ndarray, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorPoint3(self, key: int, prior: numpy.ndarray, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorPose2(self, key: int, prior: Pose2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorPose3(self, key: int, prior: Pose3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorRot2(self, key: int, prior: Rot2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorRot3(self, key: int, prior: Rot3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorSO3(self, key: int, prior: SO3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorSO4(self, key: int, prior: SO4, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorStereoPoint2(self, key: int, prior: StereoPoint2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def addPriorVector(self, key: int, prior: numpy.ndarray, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def at(self, *args, **kwargs) -> Any: ...
    def clone(self) -> NonlinearFactorGraph: ...
    def deserialize(self, serialized: str) -> None: ...
    def empty(self) -> bool: ...
    def equals(self, fg: NonlinearFactorGraph, tol: float) -> bool: ...
    def error(self, values) -> float: ...
    def exists(self, idx: int) -> bool: ...
    def keyVector(self, *args, **kwargs) -> Any: ...
    def keys(self) -> KeySet: ...
    def linearize(self, values) -> GaussianFactorGraph: ...
    def nrFactors(self) -> int: ...
    def orderingCOLAMD(self) -> Ordering: ...
    def printErrors(self, values) -> None: ...
    def print_(self, s: str) -> None: ...
    def probPrime(self, values) -> float: ...
    @overload
    def push_back(self, factors: NonlinearFactorGraph) -> None: ...
    @overload
    def push_back(self, factor) -> None: ...
    @overload
    def push_back(*args, **kwargs) -> Any: ...
    def remove(self, i: int) -> None: ...
    def replace(self, i: int, factors) -> None: ...
    def resize(self, size: int) -> None: ...
    def saveGraph(self, s: str) -> None: ...
    def serialize(self) -> str: ...
    def size(self) -> int: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class NonlinearISAM:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, reorderInterval: int) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def bayesTree(self) -> GaussianISAM: ...
    def estimate(self) -> Values: ...
    def getFactorsUnsafe(self) -> NonlinearFactorGraph: ...
    def getLinearizationPoint(self) -> Values: ...
    def marginalCovariance(self, key: int) -> numpy.ndarray: ...
    def printStats(self) -> None: ...
    def print_(self, s: str) -> None: ...
    def reorderCounter(self) -> int: ...
    def reorderInterval(self) -> int: ...
    def reorder_relinearize(self) -> None: ...
    def saveGraph(self, s: str) -> None: ...
    def update(self, newFactors: NonlinearFactorGraph, initialValues: Values) -> None: ...

class NonlinearOptimizer:
    def __init__(self, *args, **kwargs) -> None: ...
    def error(self) -> float: ...
    def graph(self) -> NonlinearFactorGraph: ...
    def iterate(self) -> GaussianFactorGraph: ...
    def iterations(self) -> int: ...
    def optimize(self) -> Values: ...
    def optimizeSafely(self) -> Values: ...
    def values(self) -> Values: ...

class NonlinearOptimizerParams:
    def __init__(self) -> None: ...
    def getAbsoluteErrorTol(self) -> float: ...
    def getErrorTol(self) -> float: ...
    def getLinearSolverType(self) -> str: ...
    def getMaxIterations(self) -> int: ...
    def getOrderingType(self) -> str: ...
    def getRelativeErrorTol(self) -> float: ...
    def getVerbosity(self) -> str: ...
    def isCholmod(self) -> bool: ...
    def isIterative(self) -> bool: ...
    def isMultifrontal(self) -> bool: ...
    def isSequential(self) -> bool: ...
    def print_(self, s: str) -> None: ...
    def setAbsoluteErrorTol(self, value: float) -> None: ...
    def setErrorTol(self, value: float) -> None: ...
    def setIterativeParams(self, params: IterativeOptimizationParameters) -> None: ...
    def setLinearSolverType(self, solver: str) -> None: ...
    def setMaxIterations(self, value: int) -> None: ...
    def setOrdering(self, ordering: Ordering) -> None: ...
    def setOrderingType(self, ordering: str) -> None: ...
    def setRelativeErrorTol(self, value: float) -> None: ...
    def setVerbosity(self, s: str) -> None: ...

class Ordering:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: Ordering) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def at(self, key: int) -> int: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, ord: Ordering, tol: float) -> bool: ...
    def print_(self, s: str) -> None: ...
    def push_back(self, key: int) -> None: ...
    def serialize(self) -> str: ...
    def size(self) -> int: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PCGSolverParameters(ConjugateGradientParameters):
    def __init__(self) -> None: ...
    @overload
    def print_(self) -> None: ...
    @overload
    def print_(self, s: str) -> None: ...
    def setPreconditionerParams(self, preconditioner: PreconditionerParameters) -> None: ...

class PinholeCameraCal3Bundler:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pose: Pose3) -> None: ...
    @overload
    def __init__(self, pose: Pose3, K: Cal3Bundler) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def Level(self, *args, **kwargs) -> Any: ...
    def Lookat(self, *args, **kwargs) -> Any: ...
    def Project(self, *args, **kwargs) -> Any: ...
    def backproject(self, p: numpy.ndarray, depth: float) -> numpy.ndarray: ...
    def calibration(self) -> Cal3Bundler: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def equals(self, camera: PinholeCameraCal3Bundler, tol: float) -> bool: ...
    def localCoordinates(self, T2: PinholeCameraCal3Bundler) -> numpy.ndarray: ...
    def pose(self) -> Pose3: ...
    def print_(self, s: str) -> None: ...
    def project(self, point: numpy.ndarray) -> numpy.ndarray: ...
    def projectSafe(self, pw: numpy.ndarray) -> Tuple[numpy.ndarray,bool]: ...
    @overload
    def range(self, point: numpy.ndarray) -> float: ...
    @overload
    def range(self, pose: Pose3) -> float: ...
    @overload
    def range(*args, **kwargs) -> Any: ...
    def retract(self, d: numpy.ndarray) -> PinholeCameraCal3Bundler: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PinholeCameraCal3DS2:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pose: Pose3) -> None: ...
    @overload
    def __init__(self, pose: Pose3, K: Cal3DS2) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def Level(self, *args, **kwargs) -> Any: ...
    def Lookat(self, *args, **kwargs) -> Any: ...
    def Project(self, *args, **kwargs) -> Any: ...
    def backproject(self, p: numpy.ndarray, depth: float) -> numpy.ndarray: ...
    def calibration(self) -> Cal3DS2: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def equals(self, camera: PinholeCameraCal3DS2, tol: float) -> bool: ...
    def localCoordinates(self, T2: PinholeCameraCal3DS2) -> numpy.ndarray: ...
    def pose(self) -> Pose3: ...
    def print_(self, s: str) -> None: ...
    def project(self, point: numpy.ndarray) -> numpy.ndarray: ...
    def projectSafe(self, pw: numpy.ndarray) -> Tuple[numpy.ndarray,bool]: ...
    @overload
    def range(self, point: numpy.ndarray) -> float: ...
    @overload
    def range(self, pose: Pose3) -> float: ...
    @overload
    def range(*args, **kwargs) -> Any: ...
    def retract(self, d: numpy.ndarray) -> PinholeCameraCal3DS2: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PinholeCameraCal3Unified:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pose: Pose3) -> None: ...
    @overload
    def __init__(self, pose: Pose3, K: Cal3Unified) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def Level(self, *args, **kwargs) -> Any: ...
    def Lookat(self, *args, **kwargs) -> Any: ...
    def Project(self, *args, **kwargs) -> Any: ...
    def backproject(self, p: numpy.ndarray, depth: float) -> numpy.ndarray: ...
    def calibration(self) -> Cal3Unified: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def equals(self, camera: PinholeCameraCal3Unified, tol: float) -> bool: ...
    def localCoordinates(self, T2: PinholeCameraCal3Unified) -> numpy.ndarray: ...
    def pose(self) -> Pose3: ...
    def print_(self, s: str) -> None: ...
    def project(self, point: numpy.ndarray) -> numpy.ndarray: ...
    def projectSafe(self, pw: numpy.ndarray) -> Tuple[numpy.ndarray,bool]: ...
    @overload
    def range(self, point: numpy.ndarray) -> float: ...
    @overload
    def range(self, pose: Pose3) -> float: ...
    @overload
    def range(*args, **kwargs) -> Any: ...
    def retract(self, d: numpy.ndarray) -> PinholeCameraCal3Unified: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PinholeCameraCal3_S2:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pose: Pose3) -> None: ...
    @overload
    def __init__(self, pose: Pose3, K: Cal3_S2) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def Level(self, *args, **kwargs) -> Any: ...
    def Lookat(self, *args, **kwargs) -> Any: ...
    def Project(self, *args, **kwargs) -> Any: ...
    def backproject(self, p: numpy.ndarray, depth: float) -> numpy.ndarray: ...
    def calibration(self) -> Cal3_S2: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def equals(self, camera: PinholeCameraCal3_S2, tol: float) -> bool: ...
    def localCoordinates(self, T2: PinholeCameraCal3_S2) -> numpy.ndarray: ...
    def pose(self) -> Pose3: ...
    def print_(self, s: str) -> None: ...
    def project(self, point: numpy.ndarray) -> numpy.ndarray: ...
    def projectSafe(self, pw: numpy.ndarray) -> Tuple[numpy.ndarray,bool]: ...
    @overload
    def range(self, point: numpy.ndarray) -> float: ...
    @overload
    def range(self, pose: Pose3) -> float: ...
    @overload
    def range(*args, **kwargs) -> Any: ...
    def retract(self, d: numpy.ndarray) -> PinholeCameraCal3_S2: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Point2Vector:
    __hash__: Any = ...
    __pybind11_module_local_v4_gcc_libstdcpp_cxxabi1014__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Point2Vector) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: numpy.ndarray) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: numpy.ndarray) -> int: ...
    @overload
    def extend(self, L: Point2Vector) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: numpy.ndarray) -> None: ...
    @overload
    def pop(self) -> numpy.ndarray: ...
    @overload
    def pop(self, i: int) -> numpy.ndarray: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def remove(self, x: numpy.ndarray) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: numpy.ndarray) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    def __eq__(self, arg0: Point2Vector) -> bool: ... # type: ignore[override]
    @overload
    def __getitem__(self, s: slice) -> Point2Vector: ...
    @overload
    def __getitem__(self, arg0: int) -> numpy.ndarray: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: Point2Vector) -> bool: ... # type: ignore[override]
    @overload
    def __setitem__(self, arg0: int, arg1: numpy.ndarray) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: Point2Vector) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class Point3Pairs:
    __hash__: Any = ...
    __pybind11_module_local_v4_gcc_libstdcpp_cxxabi1014__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Point3Pairs) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: Tuple[numpy.ndarray,numpy.ndarray]) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: Tuple[numpy.ndarray,numpy.ndarray]) -> int: ...
    @overload
    def extend(self, L: Point3Pairs) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: Tuple[numpy.ndarray,numpy.ndarray]) -> None: ...
    @overload
    def pop(self) -> Tuple[numpy.ndarray,numpy.ndarray]: ...
    @overload
    def pop(self, i: int) -> Tuple[numpy.ndarray,numpy.ndarray]: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def remove(self, x: Tuple[numpy.ndarray,numpy.ndarray]) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: Tuple[numpy.ndarray,numpy.ndarray]) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    def __eq__(self, arg0: Point3Pairs) -> bool: ... # type: ignore[override]
    @overload
    def __getitem__(self, s: slice) -> Point3Pairs: ...
    @overload
    def __getitem__(self, arg0: int) -> Tuple[numpy.ndarray,numpy.ndarray]: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: Point3Pairs) -> bool: ... # type: ignore[override]
    @overload
    def __setitem__(self, arg0: int, arg1: Tuple[numpy.ndarray,numpy.ndarray]) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: Point3Pairs) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class Pose2:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: Pose2) -> None: ...
    @overload
    def __init__(self, x: float, y: float, theta: float) -> None: ...
    @overload
    def __init__(self, theta: float, t: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, r: Rot2, t: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, v: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Adjoint(self, xi: numpy.ndarray) -> numpy.ndarray: ...
    def AdjointMap(self) -> numpy.ndarray: ...
    def Expmap(self, *args, **kwargs) -> Any: ...
    def ExpmapDerivative(self, *args, **kwargs) -> Any: ...
    def Logmap(self, *args, **kwargs) -> Any: ...
    def LogmapDerivative(self, *args, **kwargs) -> Any: ...
    def adjointMap_(self, *args, **kwargs) -> Any: ...
    def adjointTranspose(self, *args, **kwargs) -> Any: ...
    def adjoint_(self, *args, **kwargs) -> Any: ...
    def bearing(self, point: numpy.ndarray) -> Rot2: ...
    def between(self, p2: Pose2) -> Pose2: ...
    def compose(self, p2: Pose2) -> Pose2: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, pose: Pose2, tol: float) -> bool: ...
    def identity(self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Pose2: ...
    def localCoordinates(self, p: Pose2) -> numpy.ndarray: ...
    def logmap(self, p: Pose2) -> numpy.ndarray: ...
    def matrix(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def range(self, point: numpy.ndarray) -> float: ...
    def retract(self, v: numpy.ndarray) -> Pose2: ...
    def rotation(self) -> Rot2: ...
    def serialize(self) -> str: ...
    def theta(self) -> float: ...
    def transformFrom(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def transformTo(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def translation(self) -> numpy.ndarray: ...
    def wedge(self, *args, **kwargs) -> Any: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def __getstate__(self) -> tuple: ...
    def __mul__(self, arg0: Pose2) -> Pose2: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Pose3:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: Pose3) -> None: ...
    @overload
    def __init__(self, r: Rot3, t: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, pose2: Pose2) -> None: ...
    @overload
    def __init__(self, mat: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Adjoint(self, xi: numpy.ndarray) -> numpy.ndarray: ...
    def AdjointMap(self) -> numpy.ndarray: ...
    def Expmap(self, *args, **kwargs) -> Any: ...
    def ExpmapDerivative(self, *args, **kwargs) -> Any: ...
    def Logmap(self, *args, **kwargs) -> Any: ...
    def LogmapDerivative(self, *args, **kwargs) -> Any: ...
    def adjointMap_(self, *args, **kwargs) -> Any: ...
    def adjointTranspose(self, *args, **kwargs) -> Any: ...
    def adjoint_(self, *args, **kwargs) -> Any: ...
    def between(self, pose: Pose3) -> Pose3: ...
    def compose(self, pose: Pose3) -> Pose3: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, pose: Pose3, tol: float) -> bool: ...
    def identity(self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Pose3: ...
    def localCoordinates(self, pose: Pose3) -> numpy.ndarray: ...
    def logmap(self, pose: Pose3) -> numpy.ndarray: ...
    def matrix(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    @overload
    def range(self, point: numpy.ndarray) -> float: ...
    @overload
    def range(self, pose: Pose3) -> float: ...
    @overload
    def range(*args, **kwargs) -> Any: ...
    def retract(self, v: numpy.ndarray) -> Pose3: ...
    def rotation(self) -> Rot3: ...
    def serialize(self) -> str: ...
    def transformFrom(self, point: numpy.ndarray) -> numpy.ndarray: ...
    def transformPoseFrom(self, pose: Pose3) -> Pose3: ...
    def transformPoseTo(self, pose: Pose3) -> Pose3: ...
    def transformTo(self, point: numpy.ndarray) -> numpy.ndarray: ...
    def translation(self) -> numpy.ndarray: ...
    def wedge(self, *args, **kwargs) -> Any: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...
    def __getstate__(self) -> tuple: ...
    def __mul__(self, arg0: Pose3) -> Pose3: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Pose3AttitudeFactor(NonlinearFactor):
    @overload
    def __init__(self, key: int, nZ: Unit3, model: gtsam.noiseModel.Diagonal, bRef: Unit3) -> None: ...
    @overload
    def __init__(self, key: int, nZ: Unit3, model: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def bRef(self) -> Unit3: ...
    def equals(self, expected: NonlinearFactor, tol: float) -> bool: ...
    def nZ(self) -> Unit3: ...
    def print_(self, s: str) -> None: ...

class Pose3Pairs:
    __pybind11_module_local_v4_gcc_libstdcpp_cxxabi1014__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Pose3Pairs) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: Tuple[Pose3,Pose3]) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: Pose3Pairs) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: Tuple[Pose3,Pose3]) -> None: ...
    @overload
    def pop(self) -> Tuple[Pose3,Pose3]: ...
    @overload
    def pop(self, i: int) -> Tuple[Pose3,Pose3]: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    @overload
    def __getitem__(self, s: slice) -> Pose3Pairs: ...
    @overload
    def __getitem__(self, arg0: int) -> Tuple[Pose3,Pose3]: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Tuple[Pose3,Pose3]) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: Pose3Pairs) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class Pose3Vector:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Pose3Vector) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def append(self, x: Pose3) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: Pose3Vector) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: Pose3) -> None: ...
    @overload
    def pop(self) -> Pose3: ...
    @overload
    def pop(self, i: int) -> Pose3: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    @overload
    def __getitem__(self, s: slice) -> Pose3Vector: ...
    @overload
    def __getitem__(self, arg0: int) -> Pose3: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Pose3) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: Pose3Vector) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...

class PoseRotationPrior2D(NoiseModelFactor):
    def __init__(self, key: int, pose_z: Pose2, noiseModel: gtsam.noiseModel.Base) -> None: ...

class PoseRotationPrior3D(NoiseModelFactor):
    def __init__(self, key: int, pose_z: Pose3, noiseModel: gtsam.noiseModel.Base) -> None: ...

class PoseTranslationPrior2D(NoiseModelFactor):
    def __init__(self, key: int, pose_z: Pose2, noiseModel: gtsam.noiseModel.Base) -> None: ...

class PoseTranslationPrior3D(NoiseModelFactor):
    def __init__(self, key: int, pose_z: Pose3, noiseModel: gtsam.noiseModel.Base) -> None: ...

class PreconditionerParameters:
    def __init__(self) -> None: ...

class PreintegratedAhrsMeasurements:
    @overload
    def __init__(self, bias: numpy.ndarray, measuredOmegaCovariance: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, rhs: PreintegratedAhrsMeasurements) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def biasHat(self) -> numpy.ndarray: ...
    def deltaRij(self) -> Rot3: ...
    def deltaTij(self) -> float: ...
    def equals(self, expected: PreintegratedAhrsMeasurements, tol: float) -> bool: ...
    def integrateMeasurement(self, measuredOmega: numpy.ndarray, deltaT: float) -> None: ...
    def print_(self, s: str) -> None: ...
    def resetIntegration(self) -> None: ...

class PreintegratedCombinedMeasurements:
    @overload
    def __init__(self, params: PreintegrationCombinedParams) -> None: ...
    @overload
    def __init__(self, params: PreintegrationCombinedParams, bias: imuBias.ConstantBias) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def biasHat(self) -> imuBias.ConstantBias: ...
    def biasHatVector(self) -> numpy.ndarray: ...
    def deltaPij(self) -> numpy.ndarray: ...
    def deltaRij(self) -> Rot3: ...
    def deltaTij(self) -> float: ...
    def deltaVij(self) -> numpy.ndarray: ...
    def equals(self, expected: PreintegratedCombinedMeasurements, tol: float) -> bool: ...
    def integrateMeasurement(self, measuredAcc: numpy.ndarray, measuredOmega: numpy.ndarray, deltaT: float) -> None: ...
    def predict(self, state_i: NavState, bias: imuBias.ConstantBias) -> NavState: ...
    def preintMeasCov(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def resetIntegration(self) -> None: ...
    def resetIntegrationAndSetBias(self, biasHat: imuBias.ConstantBias) -> None: ...

class PreintegratedImuMeasurements:
    @overload
    def __init__(self, params: PreintegrationParams) -> None: ...
    @overload
    def __init__(self, params: PreintegrationParams, bias: imuBias.ConstantBias) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def biasHat(self) -> imuBias.ConstantBias: ...
    def biasHatVector(self) -> numpy.ndarray: ...
    def deltaPij(self) -> numpy.ndarray: ...
    def deltaRij(self) -> Rot3: ...
    def deltaTij(self) -> float: ...
    def deltaVij(self) -> numpy.ndarray: ...
    def equals(self, expected: PreintegratedImuMeasurements, tol: float) -> bool: ...
    def integrateMeasurement(self, measuredAcc: numpy.ndarray, measuredOmega: numpy.ndarray, deltaT: float) -> None: ...
    def predict(self, state_i: NavState, bias: imuBias.ConstantBias) -> NavState: ...
    def preintMeasCov(self) -> numpy.ndarray: ...
    def preintegrated(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def resetIntegration(self) -> None: ...
    def resetIntegrationAndSetBias(self, biasHat: imuBias.ConstantBias) -> None: ...

class PreintegratedRotationParams:
    def __init__(self) -> None: ...
    def equals(self, expected: PreintegratedRotationParams, tol: float) -> bool: ...
    def getBodyPSensor(self, *args, **kwargs) -> Any: ...
    def getGyroscopeCovariance(self) -> numpy.ndarray: ...
    def getOmegaCoriolis(self, *args, **kwargs) -> Any: ...
    def print_(self, s: str) -> None: ...
    def setBodyPSensor(self, pose: Pose3) -> None: ...
    def setGyroscopeCovariance(self, cov: numpy.ndarray) -> None: ...
    def setOmegaCoriolis(self, omega: numpy.ndarray) -> None: ...

class PreintegrationCombinedParams(PreintegrationParams):
    def __init__(self, n_gravity: numpy.ndarray) -> None: ...
    def MakeSharedD(self, *args, **kwargs) -> Any: ...
    def MakeSharedU(self, *args, **kwargs) -> Any: ...
    def equals(self, expected: PreintegrationCombinedParams, tol: float) -> bool: ... # type: ignore[override]
    def getBiasAccCovariance(self) -> numpy.ndarray: ...
    def getBiasAccOmegaInt(self) -> numpy.ndarray: ...
    def getBiasOmegaCovariance(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def setBiasAccCovariance(self, cov: numpy.ndarray) -> None: ...
    def setBiasAccOmegaInt(self, cov: numpy.ndarray) -> None: ...
    def setBiasOmegaCovariance(self, cov: numpy.ndarray) -> None: ...

class PreintegrationParams(PreintegratedRotationParams):
    def __init__(self, n_gravity: numpy.ndarray) -> None: ...
    def MakeSharedD(self, *args, **kwargs) -> Any: ...
    def MakeSharedU(self, *args, **kwargs) -> Any: ...
    def equals(self, expected: PreintegrationParams, tol: float) -> bool: ... # type: ignore[override]
    def getAccelerometerCovariance(self) -> numpy.ndarray: ...
    def getIntegrationCovariance(self) -> numpy.ndarray: ...
    def getUse2ndOrderCoriolis(self) -> bool: ...
    def print_(self, s: str) -> None: ...
    def setAccelerometerCovariance(self, cov: numpy.ndarray) -> None: ...
    def setIntegrationCovariance(self, cov: numpy.ndarray) -> None: ...
    def setUse2ndOrderCoriolis(self, flag: bool) -> None: ...

class PriorFactorCal3Bundler(NoiseModelFactor):
    def __init__(self, key: int, prior: Cal3Bundler, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> Cal3Bundler: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorCal3DS2(NoiseModelFactor):
    def __init__(self, key: int, prior: Cal3DS2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> Cal3DS2: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorCal3_S2(NoiseModelFactor):
    def __init__(self, key: int, prior: Cal3_S2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> Cal3_S2: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorCalibratedCamera(NoiseModelFactor):
    def __init__(self, key: int, prior: CalibratedCamera, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> CalibratedCamera: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorConstantBias(NoiseModelFactor):
    def __init__(self, key: int, prior, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self, *args, **kwargs) -> Any: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorDouble(NoiseModelFactor):
    def __init__(self, key: int, prior: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> float: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorPinholeCameraCal3Bundler(NoiseModelFactor):
    def __init__(self, key: int, prior, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self, *args, **kwargs) -> Any: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorPinholeCameraCal3_S2(NoiseModelFactor):
    def __init__(self, key: int, prior, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self, *args, **kwargs) -> Any: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorPoint2(NoiseModelFactor):
    def __init__(self, key: int, prior: numpy.ndarray, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorPoint3(NoiseModelFactor):
    def __init__(self, key: int, prior: numpy.ndarray, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorPose2(NoiseModelFactor):
    def __init__(self, key: int, prior: Pose2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> Pose2: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorPose3(NoiseModelFactor):
    def __init__(self, key: int, prior: Pose3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> Pose3: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorRot2(NoiseModelFactor):
    def __init__(self, key: int, prior: Rot2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> Rot2: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorRot3(NoiseModelFactor):
    def __init__(self, key: int, prior: Rot3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> Rot3: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorSO3(NoiseModelFactor):
    def __init__(self, key: int, prior: SO3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> SO3: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorSO4(NoiseModelFactor):
    def __init__(self, key: int, prior: SO4, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> SO4: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorSOn(NoiseModelFactor):
    def __init__(self, key: int, prior: SOn, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> SOn: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorStereoPoint2(NoiseModelFactor):
    def __init__(self, key: int, prior: StereoPoint2, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> StereoPoint2: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorUnit3(NoiseModelFactor):
    def __init__(self, key: int, prior: Unit3, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> Unit3: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class PriorFactorVector(NoiseModelFactor):
    def __init__(self, key: int, prior: numpy.ndarray, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def prior(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Quaternion:
    def __init__(self, *args, **kwargs) -> None: ...
    def coeffs(self) -> numpy.ndarray: ...
    def w(self) -> float: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...

class RangeFactor2D(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactor3D(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactorCalibratedCamera(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactorCalibratedCameraPoint(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactorPose2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactorPose3(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactorSimpleCamera(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactorSimpleCameraPoint(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactorWithTransform2D(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base, body_T_sensor: Pose2) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactorWithTransform3D(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base, body_T_sensor: Pose3) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactorWithTransformPose2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base, body_T_sensor: Pose2) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RangeFactorWithTransformPose3(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: gtsam.noiseModel.Base, body_T_sensor: Pose3) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class RedirectCout:
    def __init__(self) -> None: ...
    def str(self) -> builtins.str: ...

class Rot2:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, theta: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Expmap(self, *args, **kwargs) -> Any: ...
    def Logmap(self, *args, **kwargs) -> Any: ...
    def atan2(self, *args, **kwargs) -> Any: ...
    def between(self, p2: Rot2) -> Rot2: ...
    def c(self) -> float: ...
    def compose(self, p2: Rot2) -> Rot2: ...
    def degrees(self) -> float: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, rot: Rot2, tol: float) -> bool: ...
    def fromAngle(self, *args, **kwargs) -> Any: ...
    def fromCosSin(self, *args, **kwargs) -> Any: ...
    def fromDegrees(self, *args, **kwargs) -> Any: ...
    def identity(self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Rot2: ...
    def localCoordinates(self, p: Rot2) -> numpy.ndarray: ...
    def logmap(self, p: Rot2) -> numpy.ndarray: ...
    def matrix(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def relativeBearing(self, *args, **kwargs) -> Any: ...
    def retract(self, v: numpy.ndarray) -> Rot2: ...
    def rotate(self, point: numpy.ndarray) -> numpy.ndarray: ...
    def s(self) -> float: ...
    def serialize(self) -> str: ...
    def theta(self) -> float: ...
    def unrotate(self, point: numpy.ndarray) -> numpy.ndarray: ...
    def __getstate__(self) -> tuple: ...
    def __mul__(self, arg0: Rot2) -> Rot2: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Rot3:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, R: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, col1: numpy.ndarray, col2: numpy.ndarray, col3: numpy.ndarray) -> None: ...
    @overload
    def __init__(self, R11: float, R12: float, R13: float, R21: float, R22: float, R23: float, R31: float, R32: float, R33: float) -> None: ...
    @overload
    def __init__(self, w: float, x: float, y: float, z: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def AxisAngle(self, *args, **kwargs) -> Any: ...
    def ClosestTo(self, *args, **kwargs) -> Any: ...
    def Expmap(self, *args, **kwargs) -> Any: ...
    def Logmap(self, *args, **kwargs) -> Any: ...
    def Pitch(self, *args, **kwargs) -> Any: ...
    def Quaternion(self, *args, **kwargs) -> Any: ...
    def Rodrigues(self, *args, **kwargs) -> Any: ...
    def Roll(self, *args, **kwargs) -> Any: ...
    def Rx(self, *args, **kwargs) -> Any: ...
    def Ry(self, *args, **kwargs) -> Any: ...
    def Rz(self, *args, **kwargs) -> Any: ...
    def RzRyRx(self, *args, **kwargs) -> Any: ...
    def Yaw(self, *args, **kwargs) -> Any: ...
    def Ypr(self, *args, **kwargs) -> Any: ...
    def axisAngle(self, *args, **kwargs) -> Any: ...
    def between(self, p2: Rot3) -> Rot3: ...
    def column(self, index: int) -> numpy.ndarray: ...
    def compose(self, p2: Rot3) -> Rot3: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, rot: Rot3, tol: float) -> bool: ...
    def identity(self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Rot3: ...
    def localCoordinates(self, p: Rot3) -> numpy.ndarray: ...
    def logmap(self, p: Rot3) -> numpy.ndarray: ...
    def matrix(self) -> numpy.ndarray: ...
    def pitch(self) -> float: ...
    def print_(self, s: str) -> None: ...
    def quaternion(self) -> numpy.ndarray: ...
    def retract(self, v: numpy.ndarray) -> Rot3: ...
    def roll(self) -> float: ...
    def rotate(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def rpy(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...
    def slerp(self, t: float, other: Rot3) -> Rot3: ...
    def toQuaternion(self) -> Any: ...
    def transpose(self) -> numpy.ndarray: ...
    def unrotate(self, p: numpy.ndarray) -> numpy.ndarray: ...
    def xyz(self) -> numpy.ndarray: ...
    def yaw(self) -> float: ...
    def ypr(self) -> numpy.ndarray: ...
    def __getstate__(self) -> tuple: ...
    def __mul__(self, arg0: Rot3) -> Rot3: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Rot3AttitudeFactor(NonlinearFactor):
    @overload
    def __init__(self, key: int, nZ: Unit3, model: gtsam.noiseModel.Diagonal, bRef: Unit3) -> None: ...
    @overload
    def __init__(self, key: int, nZ: Unit3, model: gtsam.noiseModel.Diagonal) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def bRef(self) -> Unit3: ...
    def equals(self, expected: NonlinearFactor, tol: float) -> bool: ...
    def nZ(self) -> Unit3: ...
    def print_(self, s: str) -> None: ...

class SO3:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, R: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def AxisAngle(self, *args, **kwargs) -> Any: ...
    def ClosestTo(self, *args, **kwargs) -> Any: ...
    def Expmap(self, *args, **kwargs) -> Any: ...
    def FromMatrix(self, *args, **kwargs) -> Any: ...
    def between(self, R: SO3) -> SO3: ...
    def compose(self, R: SO3) -> SO3: ...
    def equals(self, other: SO3, tol: float) -> bool: ...
    def identity(self, *args, **kwargs) -> Any: ...
    def inverse(self) -> SO3: ...
    def localCoordinates(self, R: SO3) -> numpy.ndarray: ...
    def matrix(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def retract(self, v: numpy.ndarray) -> SO3: ...
    def vec(self) -> numpy.ndarray: ...
    def __mul__(self, arg0: SO3) -> SO3: ...

class SO4:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, R: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Expmap(self, *args, **kwargs) -> Any: ...
    def FromMatrix(self, *args, **kwargs) -> Any: ...
    def between(self, Q: SO4) -> SO4: ...
    def compose(self, Q: SO4) -> SO4: ...
    def equals(self, other: SO4, tol: float) -> bool: ...
    def identity(self, *args, **kwargs) -> Any: ...
    def inverse(self) -> SO4: ...
    def localCoordinates(self, Q: SO4) -> numpy.ndarray: ...
    def matrix(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def retract(self, v: numpy.ndarray) -> SO4: ...
    def vec(self) -> numpy.ndarray: ...
    def __mul__(self, arg0: SO4) -> SO4: ...

class SOn:
    def __init__(self, n: int) -> None: ...
    def Expmap(self, *args, **kwargs) -> Any: ...
    def FromMatrix(self, *args, **kwargs) -> Any: ...
    def Lift(self, *args, **kwargs) -> Any: ...
    def between(self, Q: SOn) -> SOn: ...
    def compose(self, Q: SOn) -> SOn: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, other: SOn, tol: float) -> bool: ...
    def identity(self, *args, **kwargs) -> Any: ...
    def inverse(self) -> SOn: ...
    def localCoordinates(self, Q: SOn) -> numpy.ndarray: ...
    def matrix(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def retract(self, v: numpy.ndarray) -> SOn: ...
    def serialize(self) -> str: ...
    def vec(self) -> numpy.ndarray: ...
    def __mul__(self, arg0: SOn) -> SOn: ...

class Sampler:
    @overload
    def __init__(self, model: gtsam.noiseModel.Diagonal, seed: int) -> None: ...
    @overload
    def __init__(self, sigmas: numpy.ndarray, seed: int) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def dim(self) -> int: ...
    def model(self) -> gtsam.noiseModel.Diagonal: ...
    def sample(self) -> numpy.ndarray: ...
    def sigmas(self) -> numpy.ndarray: ...

class Scenario:
    def __init__(self, *args, **kwargs) -> None: ...
    def acceleration_b(self, t: float) -> numpy.ndarray: ...
    def acceleration_n(self, t: float) -> numpy.ndarray: ...
    def navState(self, t: float) -> NavState: ...
    def omega_b(self, t: float) -> numpy.ndarray: ...
    def pose(self, t: float) -> Pose3: ...
    def rotation(self, t: float) -> Rot3: ...
    def velocity_b(self, t: float) -> numpy.ndarray: ...
    def velocity_n(self, t: float) -> numpy.ndarray: ...

class ScenarioRunner:
    def __init__(self, scenario: Scenario, p: PreintegrationParams, imuSampleTime: float, bias: imuBias.ConstantBias) -> None: ...
    def actualAngularVelocity(self, t: float) -> numpy.ndarray: ...
    def actualSpecificForce(self, t: float) -> numpy.ndarray: ...
    def estimateCovariance(self, T: float, N: int, estimatedBias: imuBias.ConstantBias) -> numpy.ndarray: ...
    def estimateNoiseCovariance(self, N: int) -> numpy.ndarray: ...
    def gravity_n(self) -> numpy.ndarray: ...
    def imuSampleTime(self) -> float: ...
    def integrate(self, T: float, estimatedBias: imuBias.ConstantBias, corrupted: bool) -> PreintegratedImuMeasurements: ...
    def measuredAngularVelocity(self, t: float) -> numpy.ndarray: ...
    def measuredSpecificForce(self, t: float) -> numpy.ndarray: ...
    def predict(self, pim: PreintegratedImuMeasurements, estimatedBias: imuBias.ConstantBias) -> NavState: ...

class SfmData:
    def __init__(self) -> None: ...
    def add_camera(self, cam) -> None: ...
    def add_track(self, t: SfmTrack) -> None: ...
    def camera(self, *args, **kwargs) -> Any: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, expected: SfmData, tol: float) -> bool: ...
    def number_cameras(self) -> int: ...
    def number_tracks(self) -> int: ...
    def serialize(self) -> str: ...
    def track(self, idx: int) -> SfmTrack: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class SfmTrack:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pt: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def add_measurement(self, idx: int, m: numpy.ndarray) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, expected: SfmTrack, tol: float) -> bool: ...
    def measurement(self, idx: int) -> Tuple[int,numpy.ndarray]: ...
    def number_measurements(self) -> int: ...
    def point3(self) -> numpy.ndarray: ...
    def serialize(self) -> str: ...
    def siftIndex(self, idx: int) -> Tuple[int,int]: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    @property
    def b(self) -> float: ...
    @b.setter
    def b(self, val: float) -> None: ...
    @property
    def g(self) -> float: ...
    @g.setter
    def g(self, val: float) -> None: ...
    @property
    def measurements(self) -> Any: ...
    @measurements.setter
    def measurements(self, val: Any) -> None: ...
    @property
    def r(self) -> float: ...
    @r.setter
    def r(self, val: float) -> None: ...

class ShonanAveraging2:
    @overload
    def __init__(self, g2oFile: str) -> None: ...
    @overload
    def __init__(self, g2oFile: str, parameters: ShonanAveragingParameters2) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def buildGraphAt(self, p: int) -> NonlinearFactorGraph: ...
    def checkOptimality(self, values: Values) -> bool: ...
    def computeA_(self, values: Values) -> numpy.ndarray: ...
    def computeLambda_(self, values: Values) -> numpy.ndarray: ...
    def computeMinEigenValue(self, values: Values) -> float: ...
    def computeMinEigenVector(self, values: Values) -> Tuple[float,numpy.ndarray]: ...
    def cost(self, values: Values) -> float: ...
    def costAt(self, p: int, values: Values) -> float: ...
    def createOptimizerAt(self, p: int, initial: Values) -> LevenbergMarquardtOptimizer: ...
    def denseD(self) -> numpy.ndarray: ...
    def denseL(self) -> numpy.ndarray: ...
    def denseQ(self) -> numpy.ndarray: ...
    def initializeRandomly(self) -> Values: ...
    def initializeRandomlyAt(self, p: int) -> Values: ...
    def initializeWithDescent(self, p: int, values: Values, minEigenVector: numpy.ndarray, minEigenValue: float) -> Values: ...
    def keys(self, *args, **kwargs) -> Any: ...
    def measured(self, i: int) -> Rot2: ...
    def nrMeasurements(self) -> int: ...
    def nrUnknowns(self) -> int: ...
    def projectFrom(self, p: int, values: Values) -> Values: ...
    def roundSolution(self, values: Values) -> Values: ...
    def run(self, initial: Values, min_p: int, max_p: int) -> Tuple[Values,float]: ...
    def tryOptimizingAt(self, p: int, initial: Values) -> Values: ...

class ShonanAveraging3:
    @overload
    def __init__(self, g2oFile: str) -> None: ...
    @overload
    def __init__(self, g2oFile: str, parameters: ShonanAveragingParameters3) -> None: ...
    @overload
    def __init__(self, factors, std) -> None: ...
    @overload
    def __init__(self, factors, std, parameters: ShonanAveragingParameters3) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def buildGraphAt(self, p: int) -> NonlinearFactorGraph: ...
    def checkOptimality(self, values: Values) -> bool: ...
    def computeA_(self, values: Values) -> numpy.ndarray: ...
    def computeLambda_(self, values: Values) -> numpy.ndarray: ...
    def computeMinEigenValue(self, values: Values) -> float: ...
    def computeMinEigenVector(self, values: Values) -> Tuple[float,numpy.ndarray]: ...
    def cost(self, values: Values) -> float: ...
    def costAt(self, p: int, values: Values) -> float: ...
    def createOptimizerAt(self, p: int, initial: Values) -> LevenbergMarquardtOptimizer: ...
    def denseD(self) -> numpy.ndarray: ...
    def denseL(self) -> numpy.ndarray: ...
    def denseQ(self) -> numpy.ndarray: ...
    def initializeRandomly(self) -> Values: ...
    def initializeRandomlyAt(self, p: int) -> Values: ...
    def initializeWithDescent(self, p: int, values: Values, minEigenVector: numpy.ndarray, minEigenValue: float) -> Values: ...
    def keys(self, *args, **kwargs) -> Any: ...
    def measured(self, i: int) -> Rot3: ...
    def nrMeasurements(self) -> int: ...
    def nrUnknowns(self) -> int: ...
    def projectFrom(self, p: int, values: Values) -> Values: ...
    def roundSolution(self, values: Values) -> Values: ...
    def run(self, initial: Values, min_p: int, max_p: int) -> Tuple[Values,float]: ...
    def tryOptimizingAt(self, p: int, initial: Values) -> Values: ...

class ShonanAveragingParameters2:
    @overload
    def __init__(self, lm: LevenbergMarquardtParams) -> None: ...
    @overload
    def __init__(self, lm: LevenbergMarquardtParams, method: str) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def getAnchor(self) -> Tuple[int,Rot2]: ...
    def getAnchorWeight(self) -> float: ...
    def getCertifyOptimality(self) -> bool: ...
    def getGaugesWeight(self) -> float: ...
    def getKarcherWeight(self) -> float: ...
    def getLMParams(self) -> LevenbergMarquardtParams: ...
    def getOptimalityThreshold(self) -> float: ...
    def getUseHuber(self) -> bool: ...
    def print_(self) -> None: ...
    def setAnchor(self, index: int, value: Rot2) -> None: ...
    def setAnchorWeight(self, value: float) -> None: ...
    def setCertifyOptimality(self, value: bool) -> None: ...
    def setGaugesWeight(self, value: float) -> None: ...
    def setKarcherWeight(self, value: float) -> None: ...
    def setOptimalityThreshold(self, value: float) -> None: ...
    def setUseHuber(self, value: bool) -> None: ...

class ShonanAveragingParameters3:
    @overload
    def __init__(self, lm: LevenbergMarquardtParams) -> None: ...
    @overload
    def __init__(self, lm: LevenbergMarquardtParams, method: str) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def getAnchor(self) -> Tuple[int,Rot3]: ...
    def getAnchorWeight(self) -> float: ...
    def getCertifyOptimality(self) -> bool: ...
    def getGaugesWeight(self) -> float: ...
    def getKarcherWeight(self) -> float: ...
    def getLMParams(self) -> LevenbergMarquardtParams: ...
    def getOptimalityThreshold(self) -> float: ...
    def getUseHuber(self) -> bool: ...
    def print_(self) -> None: ...
    def setAnchor(self, index: int, value: Rot3) -> None: ...
    def setAnchorWeight(self, value: float) -> None: ...
    def setCertifyOptimality(self, value: bool) -> None: ...
    def setGaugesWeight(self, value: float) -> None: ...
    def setKarcherWeight(self, value: float) -> None: ...
    def setOptimalityThreshold(self, value: float) -> None: ...
    def setUseHuber(self, value: bool) -> None: ...

class ShonanFactor3(NoiseModelFactor):
    @overload
    def __init__(self, key1: int, key2: int, R12: Rot3, p: int) -> None: ...
    @overload
    def __init__(self, key1: int, key2: int, R12: Rot3, p: int, model: gtsam.noiseModel.Base) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def evaluateError(self, Q1: SOn, Q2: SOn) -> numpy.ndarray: ...

class Similarity3:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, s: float) -> None: ...
    @overload
    def __init__(self, R: Rot3, t: numpy.ndarray, s: float) -> None: ...
    @overload
    def __init__(self, R: numpy.ndarray, t: numpy.ndarray, s: float) -> None: ...
    @overload
    def __init__(self, T: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Align(self, *args, **kwargs) -> Any: ...
    def matrix(self) -> numpy.ndarray: ...
    def rotation(self) -> Rot3: ...
    def scale(self) -> float: ...
    def transformFrom(self, T: Pose3) -> Pose3: ...
    def translation(self) -> numpy.ndarray: ...

class SmartProjectionParams:
    def __init__(self) -> None: ...
    def setDynamicOutlierRejectionThreshold(self, dynOutRejectionThreshold: bool) -> None: ...
    def setEnableEPI(self, enableEPI: bool) -> None: ...
    def setLandmarkDistanceThreshold(self, landmarkDistanceThreshold: bool) -> None: ...
    def setRankTolerance(self, rankTol: float) -> None: ...

class SmartProjectionPose3Factor(NonlinearFactor):
    @overload
    def __init__(self, noise: gtsam.noiseModel.Base, K: Cal3_S2) -> None: ...
    @overload
    def __init__(self, noise: gtsam.noiseModel.Base, K: Cal3_S2, body_P_sensor: Pose3) -> None: ...
    @overload
    def __init__(self, noise: gtsam.noiseModel.Base, K: Cal3_S2, params: SmartProjectionParams) -> None: ...
    @overload
    def __init__(self, noise: gtsam.noiseModel.Base, K: Cal3_S2, body_P_sensor: Pose3, params: SmartProjectionParams) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def add(self, measured_i: numpy.ndarray, poseKey_i: int) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def serialize(self) -> str: ...

class StereoCamera:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pose: Pose3, K: Cal3_S2Stereo) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def backproject(self, p: StereoPoint2) -> numpy.ndarray: ...
    def baseline(self) -> float: ...
    def calibration(self) -> Cal3_S2Stereo: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def equals(self, camera: StereoCamera, tol: float) -> bool: ...
    def localCoordinates(self, T2: StereoCamera) -> numpy.ndarray: ...
    def pose(self) -> Pose3: ...
    def print_(self, s: str) -> None: ...
    def project(self, point: numpy.ndarray) -> StereoPoint2: ...
    def retract(self, d: numpy.ndarray) -> StereoCamera: ...
    def serialize(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class StereoPoint2:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, uL: float, uR: float, v: float) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Expmap(self, *args, **kwargs) -> Any: ...
    def Logmap(self, *args, **kwargs) -> Any: ...
    def between(self, p2: StereoPoint2) -> StereoPoint2: ...
    def compose(self, p2: StereoPoint2) -> StereoPoint2: ...
    def deserialize(self, serialized: str) -> None: ...
    def equals(self, point: StereoPoint2, tol: float) -> bool: ...
    def identity(self, *args, **kwargs) -> Any: ...
    def inverse(self) -> StereoPoint2: ...
    def localCoordinates(self, p: StereoPoint2) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def retract(self, v: numpy.ndarray) -> StereoPoint2: ...
    def serialize(self) -> str: ...
    def uL(self) -> float: ...
    def uR(self) -> float: ...
    def v(self) -> float: ...
    def vector(self) -> numpy.ndarray: ...
    def __add__(self, arg0: StereoPoint2) -> StereoPoint2: ...
    def __getstate__(self) -> tuple: ...
    def __neg__(self) -> StereoPoint2: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def __sub__(self, arg0: StereoPoint2) -> StereoPoint2: ...

class SubgraphSolver:
    @overload
    def __init__(self, A: GaussianFactorGraph, parameters: SubgraphSolverParameters, ordering) -> None: ...
    @overload
    def __init__(self, Ab1: GaussianFactorGraph, Ab2: GaussianFactorGraph, parameters: SubgraphSolverParameters, ordering) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def optimize(self) -> VectorValues: ...

class SubgraphSolverParameters(ConjugateGradientParameters):
    def __init__(self) -> None: ...
    def print_(self) -> None: ...

class Symbol:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, c: str, j: int) -> None: ...
    @overload
    def __init__(self, key: int) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def chr(self) -> int: ...
    def equals(self, expected: Symbol, tol: float) -> bool: ...
    def index(self) -> int: ...
    def key(self) -> int: ...
    def print_(self, s: str) -> None: ...
    def string(self) -> str: ...

class SymbolicBayesNet:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: SymbolicBayesNet) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def at(self, idx: int) -> SymbolicConditional: ...
    def back(self) -> SymbolicConditional: ...
    def equals(self, other: SymbolicBayesNet, tol: float) -> bool: ...
    def front(self) -> SymbolicConditional: ...
    def print_(self, s: str) -> None: ...
    @overload
    def push_back(self, conditional: SymbolicConditional) -> None: ...
    @overload
    def push_back(self, bayesNet: SymbolicBayesNet) -> None: ...
    @overload
    def push_back(*args, **kwargs) -> Any: ...
    def saveGraph(self, s: str) -> None: ...
    def size(self) -> int: ...

class SymbolicBayesTree:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: SymbolicBayesTree) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def clear(self) -> None: ...
    def deleteCachedShortcuts(self) -> None: ...
    def equals(self, other: SymbolicBayesTree, tol: float) -> bool: ...
    def joint(self, key1: int, key2: int) -> SymbolicFactorGraph: ...
    def jointBayesNet(self, key1: int, key2: int) -> SymbolicBayesNet: ...
    def marginalFactor(self, key: int) -> SymbolicConditional: ...
    def numCachedSeparatorMarginals(self) -> int: ...
    def print_(self, s: str) -> None: ...
    def saveGraph(self, s: str) -> None: ...
    def size(self) -> int: ...

class SymbolicConditional(SymbolicFactor):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: SymbolicConditional) -> None: ...
    @overload
    def __init__(self, key: int) -> None: ...
    @overload
    def __init__(self, key: int, parent: int) -> None: ...
    @overload
    def __init__(self, key: int, parent1: int, parent2: int) -> None: ...
    @overload
    def __init__(self, key: int, parent1: int, parent2: int, parent3: int) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def FromKeys(self, *args, **kwargs) -> Any: ...
    def equals(self, other: SymbolicConditional, tol: float) -> bool: ... # type: ignore[override]
    def nrFrontals(self) -> int: ...
    def nrParents(self) -> int: ...
    def print_(self, s: str) -> None: ...

class SymbolicFactor:
    @overload
    def __init__(self, f: SymbolicFactor) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, j: int) -> None: ...
    @overload
    def __init__(self, j1: int, j2: int) -> None: ...
    @overload
    def __init__(self, j1: int, j2: int, j3: int) -> None: ...
    @overload
    def __init__(self, j1: int, j2: int, j3: int, j4: int) -> None: ...
    @overload
    def __init__(self, j1: int, j2: int, j3: int, j4: int, j5: int) -> None: ...
    @overload
    def __init__(self, j1: int, j2: int, j3: int, j4: int, j5: int, j6: int) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def FromKeys(self, *args, **kwargs) -> Any: ...
    def equals(self, other: SymbolicFactor, tol: float) -> bool: ...
    def keys(self, *args, **kwargs) -> Any: ...
    def print_(self, s: str) -> None: ...
    def size(self) -> int: ...

class SymbolicFactorGraph:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, bayesNet) -> None: ...
    @overload
    def __init__(self, bayesTree) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def eliminateMultifrontal(*args, **kwargs) -> Any: ...
    def eliminatePartialMultifrontal(*args, **kwargs) -> Any: ...
    def eliminatePartialSequential(*args, **kwargs) -> Any: ...
    def eliminateSequential(*args, **kwargs) -> Any: ...
    def equals(self, rhs: SymbolicFactorGraph, tol: float) -> bool: ...
    def exists(self, idx: int) -> bool: ...
    def keys(self) -> KeySet: ...
    def marginal(self, key_vector, tbb) -> SymbolicFactorGraph: ...
    def marginalMultifrontalBayesNet(*args, **kwargs) -> Any: ...
    def print_(self, s: str) -> None: ...
    @overload
    def push_back(self, factor: SymbolicFactor) -> None: ...
    @overload
    def push_back(self, graph: SymbolicFactorGraph) -> None: ...
    @overload
    def push_back(self, bayesNet) -> None: ...
    @overload
    def push_back(self, bayesTree) -> None: ...
    @overload
    def push_back(*args, **kwargs) -> Any: ...
    @overload
    def push_factor(self, key: int) -> None: ...
    @overload
    def push_factor(self, key1: int, key2: int) -> None: ...
    @overload
    def push_factor(self, key1: int, key2: int, key3: int) -> None: ...
    @overload
    def push_factor(self, key1: int, key2: int, key3: int, key4: int) -> None: ...
    @overload
    def push_factor(*args, **kwargs) -> Any: ...
    def size(self) -> int: ...

class TranslationRecovery:
    @overload
    def __init__(self, relativeTranslations, std, lmParams: LevenbergMarquardtParams) -> None: ...
    @overload
    def __init__(self, relativeTranslations, std) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    @overload
    def run(self, scale: float) -> Values: ...
    @overload
    def run(self) -> Values: ...
    @overload
    def run(*args, **kwargs) -> Any: ...

class Unit3:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pose: numpy.ndarray) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Dim(self, *args, **kwargs) -> Any: ...
    def basis(self) -> numpy.ndarray: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    @overload
    def equals(self, pose: Unit3, tol: float) -> bool: ...
    @overload
    def equals(self, expected: Unit3, tol: float) -> bool: ...
    @overload
    def equals(*args, **kwargs) -> Any: ...
    def localCoordinates(self, s: Unit3) -> numpy.ndarray: ...
    def point3(self) -> numpy.ndarray: ...
    def print_(self, s: str) -> None: ...
    def retract(self, v: numpy.ndarray) -> Unit3: ...
    def serialize(self) -> str: ...
    def skew(self) -> numpy.ndarray: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Value:
    def __init__(self, *args, **kwargs) -> None: ...
    def dim(self) -> int: ...
    def print_(self, s: str) -> None: ...

class Values:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: Values) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def atCal3Bundler(self, j: int) -> Cal3Bundler: ...
    def atCal3DS2(self, j: int) -> Cal3DS2: ...
    def atCal3_S2(self, j: int) -> Cal3_S2: ...
    def atConstantBias(self, *args, **kwargs) -> Any: ...
    def atDouble(self, j: int) -> float: ...
    def atEssentialMatrix(self, j: int) -> EssentialMatrix: ...
    def atMatrix(self, j: int) -> numpy.ndarray: ...
    def atNavState(self, *args, **kwargs) -> Any: ...
    def atPinholeCameraCal3Bundler(self, *args, **kwargs) -> Any: ...
    def atPinholeCameraCal3_S2(self, *args, **kwargs) -> Any: ...
    def atPoint2(self, j: int) -> numpy.ndarray: ...
    def atPoint3(self, j: int) -> numpy.ndarray: ...
    def atPose2(self, j: int) -> Pose2: ...
    def atPose3(self, j: int) -> Pose3: ...
    def atRot2(self, j: int) -> Rot2: ...
    def atRot3(self, j: int) -> Rot3: ...
    def atSO3(self, j: int) -> SO3: ...
    def atSO4(self, j: int) -> SO4: ...
    def atSOn(self, j: int) -> SOn: ...
    def atUnit3(self, j: int) -> Unit3: ...
    def atVector(self, j: int) -> numpy.ndarray: ...
    def clear(self) -> None: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self) -> int: ...
    def empty(self) -> bool: ...
    def equals(self, other: Values, tol: float) -> bool: ...
    def erase(self, j: int) -> None: ...
    def exists(self, j: int) -> bool: ...
    @overload
    def insert(self, values: Values) -> None: ...
    @overload
    def insert(self, j: int, vector: numpy.ndarray) -> None: ...
    @overload
    def insert(self, j: int, matrix: numpy.ndarray) -> None: ...
    @overload
    def insert(self, j: int, point2: numpy.ndarray) -> None: ...
    @overload
    def insert(self, j: int, point3: numpy.ndarray) -> None: ...
    @overload
    def insert(self, j: int, rot2: Rot2) -> None: ...
    @overload
    def insert(self, j: int, pose2: Pose2) -> None: ...
    @overload
    def insert(self, j: int, R: SO3) -> None: ...
    @overload
    def insert(self, j: int, Q: SO4) -> None: ...
    @overload
    def insert(self, j: int, P: SOn) -> None: ...
    @overload
    def insert(self, j: int, rot3: Rot3) -> None: ...
    @overload
    def insert(self, j: int, pose3: Pose3) -> None: ...
    @overload
    def insert(self, j: int, unit3: Unit3) -> None: ...
    @overload
    def insert(self, j: int, cal3_s2: Cal3_S2) -> None: ...
    @overload
    def insert(self, j: int, cal3ds2: Cal3DS2) -> None: ...
    @overload
    def insert(self, j: int, cal3bundler: Cal3Bundler) -> None: ...
    @overload
    def insert(self, j: int, essential_matrix: EssentialMatrix) -> None: ...
    @overload
    def insert(self, j: int, simple_camera) -> None: ...
    @overload
    def insert(self, j: int, camera) -> None: ...
    @overload
    def insert(self, j: int, constant_bias) -> None: ...
    @overload
    def insert(self, j: int, nav_state) -> None: ...
    @overload
    def insert(*args, **kwargs) -> Any: ...
    def insertDouble(self, j: int, c: float) -> None: ...
    def insert_P(self, j: int, P: SOn) -> None: ...
    def insert_Q(self, j: int, Q: SO4) -> None: ...
    def insert_R(self, j: int, R: SO3) -> None: ...
    def insert_cal3_s2(self, j: int, cal3_s2: Cal3_S2) -> None: ...
    def insert_cal3bundler(self, j: int, cal3bundler: Cal3Bundler) -> None: ...
    def insert_cal3ds2(self, j: int, cal3ds2: Cal3DS2) -> None: ...
    def insert_camera(self, j: int, camera) -> None: ...
    def insert_constant_bias(self, j: int, constant_bias) -> None: ...
    def insert_essential_matrix(self, j: int, essential_matrix: EssentialMatrix) -> None: ...
    def insert_matrix(self, j: int, matrix: numpy.ndarray) -> None: ...
    def insert_nav_state(self, j: int, nav_state) -> None: ...
    def insert_point2(self, j: int, point2: numpy.ndarray) -> None: ...
    def insert_point3(self, j: int, point3: numpy.ndarray) -> None: ...
    def insert_pose2(self, j: int, pose2: Pose2) -> None: ...
    def insert_pose3(self, j: int, pose3: Pose3) -> None: ...
    def insert_rot2(self, j: int, rot2: Rot2) -> None: ...
    def insert_rot3(self, j: int, rot3: Rot3) -> None: ...
    def insert_simple_camera(self, j: int, simple_camera) -> None: ...
    def insert_unit3(self, j: int, unit3: Unit3) -> None: ...
    def insert_vector(self, j: int, vector: numpy.ndarray) -> None: ...
    def keys(self, *args, **kwargs) -> Any: ...
    def localCoordinates(self, cp: Values) -> VectorValues: ...
    def print_(self, s: str) -> None: ...
    def retract(self, delta: VectorValues) -> Values: ...
    def serialize(self) -> str: ...
    def size(self) -> int: ...
    def swap(self, values: Values) -> None: ...
    @overload
    def update(self, values: Values) -> None: ...
    @overload
    def update(self, j: int, point2: numpy.ndarray) -> None: ...
    @overload
    def update(self, j: int, point3: numpy.ndarray) -> None: ...
    @overload
    def update(self, j: int, rot2: Rot2) -> None: ...
    @overload
    def update(self, j: int, pose2: Pose2) -> None: ...
    @overload
    def update(self, j: int, R: SO3) -> None: ...
    @overload
    def update(self, j: int, Q: SO4) -> None: ...
    @overload
    def update(self, j: int, P: SOn) -> None: ...
    @overload
    def update(self, j: int, rot3: Rot3) -> None: ...
    @overload
    def update(self, j: int, pose3: Pose3) -> None: ...
    @overload
    def update(self, j: int, unit3: Unit3) -> None: ...
    @overload
    def update(self, j: int, cal3_s2: Cal3_S2) -> None: ...
    @overload
    def update(self, j: int, cal3ds2: Cal3DS2) -> None: ...
    @overload
    def update(self, j: int, cal3bundler: Cal3Bundler) -> None: ...
    @overload
    def update(self, j: int, essential_matrix: EssentialMatrix) -> None: ...
    @overload
    def update(self, j: int, simple_camera) -> None: ...
    @overload
    def update(self, j: int, camera) -> None: ...
    @overload
    def update(self, j: int, constant_bias) -> None: ...
    @overload
    def update(self, j: int, nav_state) -> None: ...
    @overload
    def update(self, j: int, vector: numpy.ndarray) -> None: ...
    @overload
    def update(self, j: int, matrix: numpy.ndarray) -> None: ...
    @overload
    def update(*args, **kwargs) -> Any: ...
    def zeroVectors(self) -> VectorValues: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class VariableIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sfg: SymbolicFactorGraph) -> None: ...
    @overload
    def __init__(self, gfg) -> None: ...
    @overload
    def __init__(self, fg) -> None: ...
    @overload
    def __init__(self, other: VariableIndex) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def equals(self, other: VariableIndex, tol: float) -> bool: ...
    def nEntries(self) -> int: ...
    def nFactors(self) -> int: ...
    def print_(self, s: str) -> None: ...
    def size(self) -> int: ...

class VectorValues:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: VectorValues) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> None: ...
    def Zero(self, *args, **kwargs) -> Any: ...
    def add(self, c: VectorValues) -> VectorValues: ...
    def addInPlace(self, c: VectorValues) -> None: ...
    def at(self, j: int) -> numpy.ndarray: ...
    def deserialize(self, serialized: str) -> None: ...
    def dim(self, j: int) -> int: ...
    def dot(self, V: VectorValues) -> float: ...
    def equals(self, expected: VectorValues, tol: float) -> bool: ...
    def exists(self, j: int) -> bool: ...
    def hasSameStructure(self, other: VectorValues) -> bool: ...
    def insert(self, j: int, value: numpy.ndarray) -> None: ...
    def norm(self) -> float: ...
    def print_(self, s: str) -> None: ...
    def scale(self, a: float) -> VectorValues: ...
    def scaleInPlace(self, a: float) -> None: ...
    def serialize(self) -> str: ...
    def setZero(self) -> None: ...
    def size(self) -> int: ...
    def squaredNorm(self) -> float: ...
    def subtract(self, c: VectorValues) -> VectorValues: ...
    def update(self, values: VectorValues) -> None: ...
    def vector(self) -> numpy.ndarray: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...
